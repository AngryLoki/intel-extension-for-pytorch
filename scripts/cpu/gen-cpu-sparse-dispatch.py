from __future__ import print_function

import argparse
import collections
import lark
import os
import re
import string
import sys


def namedtuple_with_defaults(typename, field_names, default_values=()):
    ntuple = collections.namedtuple(typename, field_names)
    ntuple.__new__.__defaults__ = (None,) * len(ntuple._fields)
    if isinstance(default_values, collections.Mapping):
        prototype = ntuple(**default_values)
    else:
        prototype = ntuple(*default_values)
    ntuple.__new__.__defaults__ = tuple(prototype)
    return ntuple


FuncDecl = namedtuple_with_defaults('FuncDecl', 'cpp_sig, aten_sig')

FuncGen = namedtuple_with_defaults(
    'FuncGen',
    'tree, xtree, rwxtree, func, xfunc, code, sig, rwsig, cppsig, funsig, mapsig, aten_sig'
)

_GRAMMAR = r"""
    start: type fnname "(" params ")"
    type: CONST? core_type refspec?
    fnname: CNAME
    refspec: REF
           | PTR
    core_type: template
        | TNAME
    template: TNAME "<" typelist ">"
    typelist: type
            | type "," typelist
    REF: "&"
    PTR: "*"
    CONST: "const"
    TNAME: /[a-zA-Z0-9_:]+/
    HEXNUMBER: /0x[0-9a-fA-F]+/
    params: param
          | param "," params
    param: type param_name param_defval?
    param_name: CNAME

    param_defval: "=" init_value
    init_value: "true"
              | "false"
              | "{}"
              | NUMBER
              | SIGNED_NUMBER
              | HEXNUMBER
              | ESCAPED_STRING

    %import common.CNAME -> CNAME
    %import common.NUMBER -> NUMBER
    %import common.SIGNED_NUMBER -> SIGNED_NUMBER
    %import common.ESCAPED_STRING -> ESCAPED_STRING
    %import common.WS
    %ignore WS
    """

_PARSER = lark.Lark(_GRAMMAR, parser='lalr', propagate_positions=True)

_XPARSER = lark.Lark(
    _GRAMMAR, parser='lalr', propagate_positions=True, keep_all_tokens=True)

_FN_BLACKLIST = set([])

_FN_BLACKLIST_REGEX = [
    # ATEN functions
    r'[^(]*cudnn',
    r'[^(]*cufft',
    r'[^(]*mkldnn',
]

_TYPE_NSMAP = {
    'Tensor': 'at::Tensor',
    'TensorList': 'at::TensorList',
    'Scalar': 'at::Scalar',
    'Storage': 'at::Storage',
    'IntList': 'at::IntList',
    'IntArrayRef': 'at::IntArrayRef',
    'Generator': 'at::Generator',
    'ScalarType': 'at::ScalarType',
    'TensorOptions': 'at::TensorOptions',
    'SparseTensorRef': 'at::SparseTensorRef',
    'Device': 'c10::Device',
    'optional': 'c10::optional',
    'MemoryFormat': 'at::MemoryFormat',
    'QScheme': 'at::QScheme',
    'ConstQuantizerPtr': 'at::ConstQuantizerPtr',
    'Dimname': 'at::Dimname',  # namedtensor-only
    'DimnameList': 'at::DimnameList',  # namedtensor-only
}

_H_HEADER = """// Autogenerated file by {gen}. Do not edit directly!
#pragma once

#include <ATen/Tensor.h>

namespace torch_ipex {{

class AtenIpexSparseTypeDefault {{
 public:
{hfuncs}
}};

void RegisterAtenTypeSparseFunctions();

}}  // namespace torch_ipex
"""

_CPP_HEADER = """// Autogenerated file by {gen}. Do not edit directly!

#include <ATen/Context.h>
#include <ATen/core/op_registration/op_registration.h>
#include <ATen/CPUGenerator.h>
#include <c10/util/Exception.h>

#include "aten_ipex_sparse_type_default.h"
#include "aten_ipex_bridge.h"
#include "utils.h"
#include "cpu/SparseOPs.h"

namespace torch_ipex {{

{funcs}

{regs}
}}  // namespace torch_ipex
"""


class Context(object):

    def __init__(self, functions):
        with open(functions, 'r') as ff:
            self.functions_data = ff.read()

    def get_function(self, name):
        if self.functions_data.find(' {}('.format(name)) >= 0:
            return 'at::{}'.format(name)

    def contain_sig(self, sig):
        if self.functions_data.find('{};'.format(sig)) >=0:
            return True
        return False


class StringEmit(object):

    def __init__(self, sref):
        self.sref = sref
        self.sval = ''
        self.pos = -1

    def __repr__(self):
        return self.sval

    def advance(self, t):
        start = t.column - 1
        end = t.end_column - 1
        pos = self.pos if self.pos >= 0 else start
        if start > pos:
            self.sval += self.sref[pos:start]
        self.sval += t.value
        self.pos = end

    def skip(self, t):
        self.pos = last_match(t) if self.pos >= 0 else -1

    def append(self, s):
        self.sval += s
        self.pos = -1


def fn_with_inplace_semantic(fname):
    if fname in _FN_WITH_ALIAS:
        return True
    else:
        return False


def list_get(l, n):
    return l[n] if n < len(l) else None


def is_blacklisted_fn(fname, mapsig):
    if fname in _FN_BLACKLIST or mapsig in _FN_BLACKLIST:
        return True
    for frx in _FN_BLACKLIST_REGEX:
        if re.match(frx, fname) or re.match(frx, mapsig):
            return True
    return False


def first_match(t):
    if isinstance(t, lark.lexer.Token):
        return t.column - 1
    assert isinstance(t, lark.tree.Tree)
    return first_match(t.children[0])


def last_match(t):
    if isinstance(t, lark.lexer.Token):
        return t.end_column - 1
    assert isinstance(t, lark.tree.Tree)
    return last_match(t.children[-1])


def for_every_token(t, fn):
    if isinstance(t, lark.lexer.Token):
        fn(t)
    else:
        assert isinstance(t, lark.tree.Tree)
        for c in t.children:
            for_every_token(c, fn)


def emit_string(t, emit, emit_fn):
    status = emit_fn(t)
    if status > 0:

        def do_emit(tok):
            emit.advance(tok)

        for_every_token(t, do_emit)
    elif status == 0:
        if isinstance(t, lark.lexer.Token):
            emit.advance(t)
        else:
            assert isinstance(t, lark.tree.Tree)
            for c in t.children:
                emit_string(c, emit, emit_fn)
    else:
        emit.skip(t)


def typed_child(t, n, ttype):
    assert isinstance(t, lark.tree.Tree)
    assert n < len(t.children)
    c = t.children[n]
    assert isinstance(c, lark.tree.Tree)
    assert c.data == ttype, t.pretty()
    return c


def rewrite_sig(tree, orig_sig, emit_fn=lambda x: 0):
    emit = StringEmit(orig_sig)
    emit_string(tree, emit, emit_fn)
    return str(emit)


def rewrite_signature(sig, tmap):
    def rewrite(t):
        if t.type == 'TNAME':
            new_type = tmap.get(t.value, None)
            if new_type is not None:
                t.value = new_type

    def emit_fn(t):
        if isinstance(t, lark.lexer.Token):
            return 0
        return -1 if t.data == 'param_defval' else 0

    xtree = _XPARSER.parse(sig)
    for_every_token(xtree, rewrite)
    return rewrite_sig(xtree, sig, emit_fn=emit_fn)


def create_stdfunc_sig(tree, orig_sig):
    def emit_fn(t):
        if isinstance(t, lark.lexer.Token):
            return 0
        return -1 if t.data == 'param_name' else 0

    emit = StringEmit(orig_sig)
    # Emit full function return type.
    emit_string(typed_child(tree, 0, 'type'), emit, emit_fn)
    emit.append('(')
    # Emit parameter list w/out parameter names.
    emit_string(typed_child(tree, 3, 'params'), emit, emit_fn)
    emit.append(')')
    return str(emit)


def create_map_sig(tree, orig_sig):
    def emit_fn(t):
        if isinstance(t, lark.lexer.Token):
            return -1 if t.type in ['CONST', 'REF', 'PTR'] else 0
        return -1 if t.data in ['param_name', 'param_defval'] else 0

    emit = StringEmit(orig_sig)
    # Emit full function return type.
    emit_string(typed_child(tree, 1, 'fnname'), emit, emit_fn)
    emit.append('(')
    # Emit parameter list w/out parameter names.
    emit_string(typed_child(tree, 3, 'params'), emit, emit_fn)
    emit.append(') -> ')
    emit_string(typed_child(tree, 0, 'type'), emit, emit_fn)
    return str(emit)


def type_core(t):
    assert isinstance(t, lark.tree.Tree)
    for c in t.children:
        if isinstance(c, lark.tree.Tree) and c.data == 'core_type':
            c = c.children[0]
            if isinstance(c, lark.lexer.Token):
                return c.value
            assert isinstance(c, lark.tree.Tree) and c.data == 'template'
            return c.children[0].value
    raise RuntimeError('Not a type tree: {}'.format(t))


def extract_list(t, l):
    assert isinstance(t, lark.tree.Tree)
    l.append(t.children[0])
    if len(t.children) == 2:
        c = t.children[1]
        if isinstance(c, lark.tree.Tree) and c.data == t.data:
            extract_list(c, l)
    return l


def get_function_signature(t, orig_sig, namefn):
    emit = StringEmit(orig_sig)
    # Emit full function return type.
    emit_string(typed_child(t, 0, 'type'), emit, lambda t: 0)
    fnname = typed_child(t, 1, 'fnname').children[0]
    xfname = namefn(fnname.value)
    emit.append(' {}('.format(xfname))
    # Emit parameter list w/out parameter names.
    emit_string(typed_child(t, 3, 'params'), emit, lambda t: 0)
    emit.append(')')
    return str(emit), fnname.value, xfname


def get_parameters(t):
    assert isinstance(t, lark.tree.Tree)
    c = t.children[2]
    assert isinstance(c, lark.tree.Tree)
    assert c.data == 'params'
    params = []
    extract_list(c, params)
    return params


def param_name(t):
    assert isinstance(t, lark.tree.Tree)
    c = t.children[1]
    assert isinstance(c, lark.tree.Tree)
    assert c.data == 'param_name'
    token = c.children[0]
    assert isinstance(token, lark.lexer.Token)
    return token.value


def param_type(t):
    assert isinstance(t, lark.tree.Tree)
    c = t.children[0]
    assert isinstance(c, lark.tree.Tree)
    return c


def generate_aten_to_ipex(fname, sig, params):
    code = '{} {{\n'.format(sig)
    param_vars = []

    for p in params:
        pname = param_name(p)
        param_vars.append(pname)

    cpu_ops_class_name = "AtenIpexCPUSparse"
    code += '  return cpu::{}::{}({});\n'.format(cpu_ops_class_name, fname, ', '.join(param_vars))
    code += '}'

    return code


def get_ipex_wrapper(fndecl):
    tree = _PARSER.parse(fndecl.cpp_sig)
    xtree = _XPARSER.parse(fndecl.cpp_sig)
    mapsig = create_map_sig(xtree, fndecl.cpp_sig)
    rwsig = rewrite_signature(fndecl.cpp_sig, _TYPE_NSMAP)
    rwxtree = _XPARSER.parse(rwsig)
    params = get_parameters(tree)

    def gen_fnname(x):
        return 'AtenIpexSparseTypeDefault::{}'.format(x)

    sig, fname, xfname = get_function_signature(rwxtree, rwsig, gen_fnname)

    if not is_blacklisted_fn(fname, mapsig):
        code = generate_aten_to_ipex(fname, sig, params)
    else:
        code = None
    return FuncGen(
        tree=tree,
        xtree=xtree,
        rwxtree=rwxtree,
        func=fname,
        xfunc=xfname,
        code=code,
        sig=fndecl.cpp_sig,
        rwsig=rwsig,
        cppsig=sig,
        mapsig=mapsig,
        funsig=create_stdfunc_sig(rwxtree, rwsig),
        aten_sig=fndecl.aten_sig)


def is_tensor_api(fndecl):
    fndecl = fndecl.replace('at::', '')
    fndecl = fndecl.replace('c10::Device', 'Device')
    m = re.search(r'\bTensor\b', fndecl)
    return m is not None, fndecl


def parse_functions(path):
    functions = []
    errors = []
    for line in open(path, 'r'):
        m = re.match(r'\s*([^\s].*); //\s+(.*)', line)
        if not m:
            continue
        fndecl = m.group(1)
        try:
            _XPARSER.parse(fndecl)
            functions.append(FuncDecl(cpp_sig=fndecl, aten_sig=m.group(2)))
        except Exception as e:
            if is_tensor_api(fndecl)[0]:
                errors.append((fndecl, str(e)))
                print('Error parsing "{}": {}'.format(fndecl, e), file=sys.stderr)
    return functions, errors


def get_mapsig_key(mapsig):
    # PyTorch generates std::tuple<> without space among the tuple types,
    # which would require special understanding in the string rewriter.
    # Since we are using this as simple key, we can just string the spaces.
    return mapsig.replace(' ', '')


def parse_local_overrides(path):
    functions = []
    fndecl = None
    for line in open(path, 'r'):
        line = line.strip()
        if not fndecl:
            m = re.match(r'static\s+(.*);', line)
            if m:
                functions.append(m.group(1))
                continue
            m = re.match(r'static\s+(.*)', line)
            if m:
                fndecl = m.group(1)
        else:
            fndecl = '{} {}'.format(fndecl, line)
            if fndecl.endswith(';'):
                functions.append(fndecl[:-1])
                fndecl = None
    assert fndecl is None

    overrides = {}
    for fndecl in functions:
        # Discard static IPEX type functions which are not ATEN.
        is_tensor, fndecl = is_tensor_api(fndecl)
        if is_tensor:
            xtree = _XPARSER.parse(fndecl)
            mapsig_key = get_mapsig_key(create_map_sig(xtree, fndecl))
            overrides[mapsig_key] = fndecl
    return overrides


def generate_registrations(code_gens, overrides):
    code = 'void RegisterAtenTypeSparseFunctions() {\n'
    code += '  static auto dispatch = torch::RegisterOperators()\n'
    overridden = set()
    for code_gen in code_gens:
        mapsig_key = get_mapsig_key(code_gen.mapsig)
        if mapsig_key in overrides:
            override_fn = 'AtenIpexSparseTypeDefault::{}'.format(code_gen.func)
            overridden.add(mapsig_key)
        else:
            override_fn = code_gen.xfunc if code_gen.code else None
        if override_fn:
            code += (
                '  .op(torch::RegisterOperators::options().schema("{}")\n      '
                '.impl_unboxedOnlyKernel<{}, &{}>(at::TensorTypeId::SparseDPCPPTensorId)\n'
                '      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))\n'.format(
                    code_gen.aten_sig, code_gen.funsig, override_fn, override_fn,
                    code_gen.aten_sig))
    return code + ';\n}\n', overridden


def generate_functions(code_gens):
    code = ''
    for code_gen in code_gens:
        if code_gen.code:
            code += '{}\n\n'.format(code_gen.code)
    return code


def generate_class_functions(code_gens):
    code = ''
    for code_gen in code_gens:
        if code_gen.code:
            code += '  static {};\n'.format(code_gen.rwsig)
    return code


def gen_output_file(args, name):
    if not args.output_folder:
        return sys.stdout
    return open(os.path.join(args.output_folder, name), 'w')


def gen_h_output_file(args):
    return gen_output_file(args, 'aten_ipex_sparse_type_default.h')


def gen_cpp_output_file(args):
    return gen_output_file(args, 'aten_ipex_sparse_type_default.cpp')


def check_overrides(overrides, overridden):
    misses = 0
    for mapsig, cpp_sig in overrides.items():
        mapsig_key = get_mapsig_key(mapsig)
        if not mapsig_key in overridden:
            misses += 1
            print('AtenIpexType Sparse function missed override: {}; // {}'.format(cpp_sig, mapsig), file=sys.stderr)
    return misses == 0


def generate(args):
    # Parse all PyTorch exposed functions
    decls, errors = parse_functions(args.declarations)
    print('Extracted {} functions ({} errors) from {}'.format(len(decls), len(errors), args.declarations), file=sys.stderr)
    assert len(errors) == 0

    overrides = parse_local_overrides(args.sparse_typedef)
    print('{} function overrides in {}'.format(len(overrides), args.sparse_typedef), file=sys.stderr)

    code_gens = []
    sparse_ctx = Context(args.sparse_header)
    for decl in decls:
        # Skip non Sparse functions
        tree = _PARSER.parse(decl.cpp_sig)
        if not sparse_ctx.contain_sig(decl.cpp_sig):
            continue
        try:
            code_gen = get_ipex_wrapper(decl)
            if code_gen:
                code_gens.append(code_gen)
        except Exception as e:
            print('Failed to generate wrapper for {}: {}'.format(decl, e), file=sys.stderr)
    print('Generated {} wrappers for {}'.format(len(code_gens), args.declarations), file=sys.stderr)

    functions = generate_functions(code_gens)
    hfunctions = generate_class_functions(code_gens)
    regs, overridden = generate_registrations(code_gens, overrides)
    # assert check_overrides(overrides, overridden)
    check_overrides(overrides, overridden)
    # Create output files ...
    print(
        _H_HEADER.format(gen=os.path.basename(sys.argv[0]), hfuncs=hfunctions),
        file=gen_h_output_file(args))
    print(
        _CPP_HEADER.format(
            gen=os.path.basename(sys.argv[0]), funcs=functions, regs=regs),
        file=gen_cpp_output_file(args))


if __name__ == '__main__':
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('--output_folder', type=str)
    arg_parser.add_argument(
        'declarations',
        type=str,
        metavar='DECLARATIONS_FROM_PYTORCH',
        help='The path to PyTorch RegistrationDeclarations.h')
    arg_parser.add_argument(
        'sparse_header',
        type=str,
        metavar='SPARSE_FUNCTIONS_FROM_PYTORCH',
        help='The path to PyTorch SparseCPUType.h')
    arg_parser.add_argument(
        'sparse_typedef',
        type=str,
        metavar='SPARSE_DEFAULT_DISPATCHER',
        help='The path to IPEX default sparse dispatch file')
    args, files = arg_parser.parse_known_args()
    print(args)
    print(files)
    generate(args)
