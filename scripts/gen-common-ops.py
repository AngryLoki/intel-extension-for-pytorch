from __future__ import print_function

import argparse
import collections
import lark
import os
import re
import string
import sys


def namedtuple_with_defaults(typename, field_names, default_values=()):
    ntuple = collections.namedtuple(typename, field_names)
    ntuple.__new__.__defaults__ = (None,) * len(ntuple._fields)
    if isinstance(default_values, collections.Mapping):
        prototype = ntuple(**default_values)
    else:
        prototype = ntuple(*default_values)
    ntuple.__new__.__defaults__ = tuple(prototype)
    return ntuple


class ArgTemplate(string.Template):
    idpattern = r'[a-z0-9_]+'


FuncDef = namedtuple_with_defaults('FuncDef', 'cpp_sig, aten_sig')

FuncGen = namedtuple_with_defaults(
    'FuncGen',
    'tree, xtree, rwxtree, func, xfunc, code, sig, rwsig, cppsig, funsig, mapsig, aten_sig'
)

FuncOpts = namedtuple_with_defaults(
    'FuncOpts',
    'ref_param, device_param, wparams, outfn_template, outfn_name, shape_check_indices'
)

_GRAMMAR = r"""
    start: type fnname "(" params ")"
    type: CONST? core_type refspec?
    fnname: CNAME
    refspec: REF
           | PTR
    core_type: template
        | TNAME
    template: TNAME "<" typelist ">"
    typelist: type
            | type "," typelist
    REF: "&"
    PTR: "*"
    CONST: "const"
    TNAME: /[a-zA-Z0-9_:]+/
    HEXNUMBER: /0x[0-9a-fA-F]+/
    params: param
          | param "," params
    param: type param_name param_defval?
    param_name: CNAME

    param_defval: "=" init_value
    init_value: "true"
              | "false"
              | "{}"
              | NUMBER
              | SIGNED_NUMBER
              | HEXNUMBER
              | ESCAPED_STRING

    %import common.CNAME -> CNAME
    %import common.NUMBER -> NUMBER
    %import common.SIGNED_NUMBER -> SIGNED_NUMBER
    %import common.ESCAPED_STRING -> ESCAPED_STRING
    %import common.WS
    %ignore WS
    """

_PARSER = lark.Lark(_GRAMMAR, parser='lalr', propagate_positions=True)

_XPARSER = lark.Lark(
    _GRAMMAR, parser='lalr', propagate_positions=True, keep_all_tokens=True)

_FN_BLACKLIST = set([])

_FN_BLACKLIST_REGEX = [
    # ATEN functions
    r'[^(]*cudnn',
    r'[^(]*cufft'
    # XLA/TPU functions
]

_TYPE_NSMAP = {
    'Tensor': 'at::Tensor',
    'TensorList': 'at::TensorList',
    'Scalar': 'at::Scalar',
    'Storage': 'at::Storage',
    'IntList': 'at::IntList',
    'IntArrayRef': 'at::IntArrayRef',
    'Generator': 'at::Generator',
    'ScalarType': 'at::ScalarType',
    'TensorOptions': 'at::TensorOptions',
    'SparseTensorRef': 'at::SparseTensorRef',
    'Device': 'c10::Device',
    'optional': 'c10::optional',
    'MemoryFormat': 'at::MemoryFormat',
    'QScheme': 'at::QScheme',
    'ConstQuantizerPtr': 'at::ConstQuantizerPtr',
    'Dimname': 'at::Dimname',  # namedtensor-only
    'DimnameList': 'at::DimnameList',  # namedtensor-only
}

_H_HEADER = """// Autogenerated file by {gen}. Do not edit directly!

#include <ATen/Tensor.h>

namespace torch_ipex {{

class AtenIpexTypeDefault {{
 public:
{hfuncs}
}};

void RegisterAtenTypeFunctions();

}}  // namespace torch_ipex
"""

_CPP_HEADER = """// Autogenerated file by {gen}. Do not edit directly!
#include "aten_ipex_type_default.h"

#include <ATen/Context.h>
#include <ATen/core/op_registration/op_registration.h>
#include <ATen/CPUGenerator.h>
#include <c10/util/Exception.h>

#include "aten_ipex_bridge.h"
#include "utils.h"
#include "cpu/OPs.h"

namespace torch_ipex {{

{funcs}

{regs}
}}  // namespace torch_ipex
"""

_FUNCTION_OPTIONS = {
    'slice(Tensor, int64_t, int64_t, int64_t, int64_t) -> Tensor':
        FuncOpts(wparams=['self']),
}


class Context(object):

    def __init__(self, functions):
        with open(functions, 'r') as ff:
            self.functions_data = ff.read()

    def get_function(self, name):
        if self.functions_data.find(' {}('.format(name)) >= 0:
            return 'at::{}'.format(name)


class StringEmit(object):

    def __init__(self, sref):
        self.sref = sref
        self.sval = ''
        self.pos = -1

    def __repr__(self):
        return self.sval

    def advance(self, t):
        start = t.column - 1
        end = t.end_column - 1
        pos = self.pos if self.pos >= 0 else start
        if start > pos:
            self.sval += self.sref[pos:start]
        self.sval += t.value
        self.pos = end

    def skip(self, t):
        self.pos = last_match(t) if self.pos >= 0 else -1

    def append(self, s):
        self.sval += s
        self.pos = -1


def list_get(l, n):
    return l[n] if n < len(l) else None


def is_blacklisted_fn(fname, mapsig):
    if fname in _FN_BLACKLIST or mapsig in _FN_BLACKLIST:
        return True
    for frx in _FN_BLACKLIST_REGEX:
        if re.match(frx, fname) or re.match(frx, mapsig):
            return True
    return False


def is_write_param(fnopts, pname, defval):
    if fnopts and fnopts.wparams:
        if pname in fnopts.wparams:
            return True
    return defval


def first_match(t):
    if isinstance(t, lark.lexer.Token):
        return t.column - 1
    assert isinstance(t, lark.tree.Tree)
    return first_match(t.children[0])


def last_match(t):
    if isinstance(t, lark.lexer.Token):
        return t.end_column - 1
    assert isinstance(t, lark.tree.Tree)
    return last_match(t.children[-1])


def for_every_token(t, fn):
    if isinstance(t, lark.lexer.Token):
        fn(t)
    else:
        assert isinstance(t, lark.tree.Tree)
        for c in t.children:
            for_every_token(c, fn)


def emit_string(t, emit, emit_fn):
    status = emit_fn(t)
    if status > 0:

        def do_emit(tok):
            emit.advance(tok)

        for_every_token(t, do_emit)
    elif status == 0:
        if isinstance(t, lark.lexer.Token):
            emit.advance(t)
        else:
            assert isinstance(t, lark.tree.Tree)
            for c in t.children:
                emit_string(c, emit, emit_fn)
    else:
        emit.skip(t)


def typed_child(t, n, ttype):
    assert isinstance(t, lark.tree.Tree)
    assert n < len(t.children)
    c = t.children[n]
    assert isinstance(c, lark.tree.Tree)
    assert c.data == ttype, t.pretty()
    return c


def rewrite_sig(tree, orig_sig, emit_fn=lambda x: 0):
    emit = StringEmit(orig_sig)
    emit_string(tree, emit, emit_fn)
    return str(emit)


def rewrite_signature(sig, tmap):
    def rewrite(t):
        if t.type == 'TNAME':
            new_type = tmap.get(t.value, None)
            if new_type is not None:
                t.value = new_type

    def emit_fn(t):
        if isinstance(t, lark.lexer.Token):
            return 0
        return -1 if t.data == 'param_defval' else 0

    xtree = _XPARSER.parse(sig)
    for_every_token(xtree, rewrite)
    return rewrite_sig(xtree, sig, emit_fn=emit_fn)


def create_stdfunc_sig(tree, orig_sig):
    def emit_fn(t):
        if isinstance(t, lark.lexer.Token):
            return 0
        return -1 if t.data == 'param_name' else 0

    emit = StringEmit(orig_sig)
    # Emit full function return type.
    emit_string(typed_child(tree, 0, 'type'), emit, emit_fn)
    emit.append('(')
    # Emit parameter list w/out parameter names.
    emit_string(typed_child(tree, 3, 'params'), emit, emit_fn)
    emit.append(')')
    return str(emit)


def create_map_sig(tree, orig_sig):
    def emit_fn(t):
        if isinstance(t, lark.lexer.Token):
            return -1 if t.type in ['CONST', 'REF', 'PTR'] else 0
        return -1 if t.data in ['param_name', 'param_defval'] else 0

    emit = StringEmit(orig_sig)
    # Emit full function return type.
    emit_string(typed_child(tree, 1, 'fnname'), emit, emit_fn)
    emit.append('(')
    # Emit parameter list w/out parameter names.
    emit_string(typed_child(tree, 3, 'params'), emit, emit_fn)
    emit.append(') -> ')
    emit_string(typed_child(tree, 0, 'type'), emit, emit_fn)
    return str(emit)


def type_core(t):
    assert isinstance(t, lark.tree.Tree)
    for c in t.children:
        if isinstance(c, lark.tree.Tree) and c.data == 'core_type':
            c = c.children[0]
            if isinstance(c, lark.lexer.Token):
                return c.value
            assert isinstance(c, lark.tree.Tree) and c.data == 'template'
            return c.children[0].value
    raise RuntimeError('Not a type tree: {}'.format(t))


def extract_list(t, l):
    assert isinstance(t, lark.tree.Tree)
    l.append(t.children[0])
    if len(t.children) == 2:
        c = t.children[1]
        if isinstance(c, lark.tree.Tree) and c.data == t.data:
            extract_list(c, l)
    return l


def get_function_name(t):
    assert isinstance(t, lark.tree.Tree)
    fname = t.children[1]
    assert isinstance(fname, lark.tree.Tree)
    assert fname.data == 'fnname'
    return fname.children[0].value


def get_function_signature(t, orig_sig, namefn):
    emit = StringEmit(orig_sig)
    # Emit full function return type.
    emit_string(typed_child(t, 0, 'type'), emit, lambda t: 0)
    fnname = typed_child(t, 1, 'fnname').children[0]
    xfname = namefn(fnname.value)
    emit.append(' {}('.format(xfname))
    # Emit parameter list w/out parameter names.
    emit_string(typed_child(t, 3, 'params'), emit, lambda t: 0)
    emit.append(')')
    return str(emit), fnname.value, xfname


def get_parameters(t):
    assert isinstance(t, lark.tree.Tree)
    c = t.children[2]
    assert isinstance(c, lark.tree.Tree)
    assert c.data == 'params'
    params = []
    extract_list(c, params)
    return params


def param_name(t):
    assert isinstance(t, lark.tree.Tree)
    c = t.children[1]
    assert isinstance(c, lark.tree.Tree)
    assert c.data == 'param_name'
    token = c.children[0]
    assert isinstance(token, lark.lexer.Token)
    return token.value


def param_type(t):
    assert isinstance(t, lark.tree.Tree)
    c = t.children[0]
    assert isinstance(c, lark.tree.Tree)
    return c


def generate_aten_to_ipex(ctx, tree, rwxtree, fname, sig, rwsig, params, fnopts):
    code = '{} {{\n'.format(sig)
    param_vars = []

    how_to_check_device = ''
    for p in params:
        ptype = param_type(p)
        cptype = type_core(ptype)
        pname = param_name(p)
        if cptype == 'TensorList':
            code += ('  TORCH_CHECK(!{}.empty())').format(pname)
            how_to_check_device = ('(check_device({}[0], DPCPPSubDev::CPU))').format(pname)
            break
        elif cptype == 'TensorOptions':
            how_to_check_device = ('(check_device({}, DPCPPSubDev::CPU))').format(pname)
            break
        elif cptype == 'Tensor':
            how_to_check_device = ('(check_device({}, DPCPPSubDev::CPU))').format(pname)
            break

    for p in params:
        pname = param_name(p)
        param_vars.append(pname)

    assert (how_to_check_device != '')
    # Check device type
    code += ('  if {} {{\n').format(how_to_check_device)
    code += '    return cpu::AtenIpexCPUDefault::{}({});\n'.format(fname, ', '.join(param_vars))
    code += '  } else {\n'
    code += '    AT_ASSERT(false);\n'
    code += '  }\n'
    code += '}'

    return code


def get_ipex_wrapper(fndef, ctx):
    tree = _PARSER.parse(fndef.cpp_sig)
    xtree = _XPARSER.parse(fndef.cpp_sig)
    mapsig = create_map_sig(xtree, fndef.cpp_sig)
    rwsig = rewrite_signature(fndef.cpp_sig, _TYPE_NSMAP)
    rwxtree = _XPARSER.parse(rwsig)
    params = get_parameters(tree)
    fnopts = _FUNCTION_OPTIONS.get(mapsig, None)

    def gen_fnname(x):
        return 'AtenIpexTypeDefault::{}'.format(x)

    sig, fname, xfname = get_function_signature(rwxtree, rwsig, gen_fnname)
    if not is_blacklisted_fn(fname, mapsig):
        code = generate_aten_to_ipex(ctx, tree, rwxtree, fname, sig, rwsig, params, fnopts)
    else:
        code = None
    return FuncGen(
        tree=tree,
        xtree=xtree,
        rwxtree=rwxtree,
        func=fname,
        xfunc=xfname,
        code=code,
        sig=fndef.cpp_sig,
        rwsig=rwsig,
        cppsig=sig,
        mapsig=mapsig,
        funsig=create_stdfunc_sig(rwxtree, rwsig),
        aten_sig=fndef.aten_sig)


def is_tensor_api(fndef):
    fndef = fndef.replace('at::', '')
    fndef = fndef.replace('c10::Device', 'Device')
    m = re.search(r'\bTensor\b', fndef)
    return m is not None, fndef


def extract_functions(path):
    functions = []
    errors = []
    for line in open(path, 'r'):
        m = re.match(r'\s*([^\s].*); //\s+(.*)', line)
        if not m:
            continue
        fndef = m.group(1)
        try:
            _XPARSER.parse(fndef)
            functions.append(FuncDef(cpp_sig=fndef, aten_sig=m.group(2)))
        except Exception as e:
            if is_tensor_api(fndef)[0]:
                errors.append((fndef, str(e)))
                print('Error parsing "{}": {}'.format(fndef, e), file=sys.stderr)
    return functions, errors


def get_mapsig_key(mapsig):
    # PyTorch generates std::tuple<> without space among the tuple types,
    # which would require special understanding in the string rewriter.
    # Since we are using this as simple key, we can just string the spaces.
    return mapsig.replace(' ', '')


def parse_local_overrides(path):
    functions = []
    fndef = None
    for line in open(path, 'r'):
        line = line.strip()
        if not fndef:
            m = re.match(r'static\s+(.*);', line)
            if m:
                functions.append(m.group(1))
                continue
            m = re.match(r'static\s+(.*)', line)
            if m:
                fndef = m.group(1)
        else:
            fndef = '{} {}'.format(fndef, line)
            if fndef.endswith(';'):
                functions.append(fndef[:-1])
                fndef = None
    assert fndef is None

    overrides = {}
    for fndef in functions:
        # Discard static XLA type functions which are not ATEN.
        is_tensor, fndef = is_tensor_api(fndef)
        if is_tensor:
            xtree = _XPARSER.parse(fndef)
            mapsig_key = get_mapsig_key(create_map_sig(xtree, fndef))
            overrides[mapsig_key] = fndef
    return overrides


def generate_registrations(fgens, overrides):
    code = 'void RegisterAtenTypeFunctions() {\n'
    code += '  static auto dispatch = torch::RegisterOperators()\n'
    overridden = set()
    for fgen in fgens:
        mapsig_key = get_mapsig_key(fgen.mapsig)
        if mapsig_key in overrides:
            override_fn = 'AtenIpexTypeDefault::{}'.format(fgen.func)
            overridden.add(mapsig_key)
        else:
            override_fn = fgen.xfunc if fgen.code else None
        if override_fn:
            code += (
                '  .op(torch::RegisterOperators::options().schema("{}")\n      '
                '.impl_unboxedOnlyKernel<{}, &{}>(at::TensorTypeId::XLATensorId)\n'
                '      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))\n'.format(
                    fgen.aten_sig, fgen.funsig, override_fn, override_fn,
                    fgen.aten_sig))
    return code + ';\n}\n', overridden


def generate_functions(fgens):
    code = ''
    for fgen in fgens:
        if fgen.code:
            code += '{}\n\n'.format(fgen.code)
    return code


def generate_class_functions(fgens):
    code = ''
    for fgen in fgens:
        if fgen.code:
            code += '  static {};\n'.format(fgen.rwsig)
    return code


def gen_output_file(args, name):
    if not args.output_folder:
        return sys.stdout
    return open(os.path.join(args.output_folder, name), 'w')


def gen_h_output_file(args):
    return gen_output_file(args, 'aten_ipex_type_default.h')


def gen_cpp_output_file(args):
    return gen_output_file(args, 'aten_ipex_type_default.cpp')


def check_overrides(overrides, overridden):
    misses = 0
    for mapsig, cpp_sig in overrides.items():
        mapsig_key = get_mapsig_key(mapsig)
        if not mapsig_key in overridden:
            misses += 1
            print(
                'AtenXlaType function missed override: {}; // {}'.format(
                    cpp_sig, mapsig),
                file=sys.stderr)
    return misses == 0


def generate(args):
    # Parse all PyTorch exposed functions
    fndefs, errors = extract_functions(args.typedef)
    print(
        'Extracted {} functions ({} errors) from {}'.format(
            len(fndefs), len(errors), args.typedef),
        file=sys.stderr)
    assert len(errors) == 0

    overrides = parse_local_overrides(args.ipextype)
    print(
        '{} function overrides in {}'.format(len(overrides), args.ipextype),
        file=sys.stderr)

    fgens = []
    ctx = Context(args.functions)
    for ts in fndefs:
        try:
            fgen = get_ipex_wrapper(ts, ctx)
            if fgen:
                fgens.append(fgen)
        except Exception as e:
            print(
                'Failed to generate wrapper for {}: {}'.format(ts, e),
                file=sys.stderr)
    print(
        'Generated {} wrappers for {}'.format(len(fgens), args.typedef),
        file=sys.stderr)

    functions = generate_functions(fgens)
    hfunctions = generate_class_functions(fgens)
    regs, overridden = generate_registrations(fgens, overrides)
    # assert check_overrides(overrides, overridden)
    check_overrides(overrides, overridden)
    # Create output files ...
    print(
        _H_HEADER.format(gen=os.path.basename(sys.argv[0]), hfuncs=hfunctions),
        file=gen_h_output_file(args))
    print(
        _CPP_HEADER.format(
            gen=os.path.basename(sys.argv[0]), funcs=functions, regs=regs),
        file=gen_cpp_output_file(args))


if __name__ == '__main__':
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('--output_folder', type=str)
    arg_parser.add_argument(
        'ipextype',
        type=str,
        metavar='IPEX_TYPE_FILE',
        help='The path to the IPEX ATEN overrides file')
    arg_parser.add_argument(
        'typedef',
        type=str,
        metavar='TYPE_DEFAULT_FILE',
        help='The path to the TypeDefault.h file')
    arg_parser.add_argument(
        'functions',
        type=str,
        metavar='FUNCTIONS_FILE',
        help='The path to the Functions.h file')
    args, files = arg_parser.parse_known_args()
    print(args)
    print(files)
    generate(args)
