// Autogenerated file by gen_code.py
// /home/gta/work/rebase_pt110/frameworks.ai.pytorch.ipex-gpu/scripts/gpu/gen_code.py
// --declarations-path
// /home/gta/work/rebase_pt110/frameworks.ai.pytorch.ipex-gpu/scripts/declarations/Declarations.yaml
// --out
// /home/gta/work/rebase_pt110/frameworks.ai.pytorch.ipex-gpu/csrc/aten/generated/ATen/
// --source-path /home/gta/work/rebase_pt110/frameworks.ai.pytorch.ipex-gpu. Do
// not edit directly!
#pragma once

#include <ATen/Tensor.h>
#include <intrinsic/ipex_intrinsic.h>

namespace at {

namespace AtenIpexTypeXPU {

void RegisterAtenTypeFunctions();

std::tuple<Tensor, Tensor> _fused_dropout(
    const Tensor& self,
    double p,
    c10::optional<Generator> generator);
Tensor _masked_scale(const Tensor& self, const Tensor& mask, double scale);
Tensor& abs_out(Tensor& out, const Tensor& self);
Tensor& sgn_out(Tensor& out, const Tensor& self);
Tensor& conj_out(Tensor& out, const Tensor& self);
Tensor& acos_out(Tensor& out, const Tensor& self);
Tensor add(const Tensor& self, const Tensor& other, const Scalar& alpha);
Tensor& add_(Tensor& self, const Tensor& other, const Scalar& alpha);
Tensor& add_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& other,
    const Scalar& alpha);
Tensor add(const Tensor& self, const Scalar& other, const Scalar& alpha);
Tensor& add_(Tensor& self, const Scalar& other, const Scalar& alpha);
Tensor addmv(
    const Tensor& self,
    const Tensor& mat,
    const Tensor& vec,
    Scalar beta,
    Scalar alpha);
Tensor& addmv_(
    const Tensor& self,
    const Tensor& mat,
    const Tensor& vec,
    Scalar beta,
    Scalar alpha);
Tensor& addmv_out(
    const Tensor& self,
    const Tensor& mat,
    const Tensor& vec,
    const Scalar& beta,
    const Scalar& alpha,
    at::Tensor& out);
Tensor addr(
    const Tensor& self,
    const Tensor& vec1,
    const Tensor& vec2,
    Scalar beta,
    Scalar alpha);
Tensor& addr_(
    Tensor& self,
    const Tensor& vec1,
    const Tensor& vec2,
    Scalar beta,
    Scalar alpha);
Tensor all(const Tensor& self, int64_t dim, bool keepdim);
Tensor& all_out(Tensor& out, const Tensor& self, int64_t dim, bool keepdim);
Tensor any(const Tensor& self, int64_t dim, bool keepdim);
Tensor& any_out(Tensor& out, const Tensor& self, int64_t dim, bool keepdim);
Tensor& arange_out(Tensor& out, Scalar start, Scalar end, Scalar step);
Tensor argmax(const Tensor& self, c10::optional<int64_t> dim, bool keepdim);
Tensor argmin(const Tensor& self, c10::optional<int64_t> dim, bool keepdim);
Tensor as_strided(
    const Tensor& self,
    IntArrayRef size,
    IntArrayRef stride,
    c10::optional<int64_t> storage_offset);
Tensor& asin_out(Tensor& out, const Tensor& self);
Tensor& atan_(Tensor& self);
Tensor& atan_out(Tensor& out, const Tensor& self);
Tensor baddbmm(
    const Tensor& self,
    const Tensor& batch1,
    const Tensor& batch2,
    const Scalar& beta,
    const Scalar& alpha);
Tensor& baddbmm_(
    Tensor& self,
    const Tensor& batch1,
    const Tensor& batch2,
    const Scalar& beta,
    const Scalar& alpha);
Tensor& baddbmm_out(
    const Tensor& self,
    const Tensor& batch1,
    const Tensor& batch2,
    const Scalar& beta,
    const Scalar& alpha,
    Tensor& out);
Tensor& bernoulli_(
    Tensor& self,
    const Tensor& p,
    c10::optional<Generator> generator);
Tensor& bernoulli_(Tensor& self, double p, c10::optional<Generator> generator);
Tensor binary_cross_entropy(
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction);
Tensor& binary_cross_entropy_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction);
Tensor binary_cross_entropy_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction);
Tensor& binary_cross_entropy_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction);
Tensor bincount(const Tensor& self, const Tensor& weights, int64_t minlength);
Tensor bitwise_not(const Tensor& self);
Tensor& bitwise_not_(Tensor& self);
Tensor& bitwise_not_out(Tensor& out, const Tensor& self);
Tensor logical_not(const Tensor& self);
Tensor& logical_not_(Tensor& self);
Tensor& logical_not_out(Tensor& out, const Tensor& self);
Tensor& logical_xor_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor& logical_and_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor& logical_or_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor bmm(const Tensor& self, const Tensor& mat2);
Tensor& bmm_out(Tensor& out, const Tensor& self, const Tensor& mat2);
Tensor& ceil_out(Tensor& out, const Tensor& self);
Tensor chain_matmul(TensorList matrices);
Tensor clamp(
    const Tensor& self,
    c10::optional<Scalar> min,
    c10::optional<Scalar> max);
Tensor& clamp_(
    Tensor& self,
    c10::optional<Scalar> min,
    c10::optional<Scalar> max);
Tensor& clamp_out(
    Tensor& out,
    const Tensor& self,
    c10::optional<Scalar> min,
    c10::optional<Scalar> max);
Tensor& clamp_max_(Tensor& self, Scalar max);
Tensor& clamp_max_out(Tensor& out, const Tensor& self, Scalar max);
Tensor& clamp_min_(Tensor& self, Scalar min);
Tensor& clamp_min_out(Tensor& out, const Tensor& self, Scalar min);
Tensor convolution_overrideable(
    const Tensor& input,
    const Tensor& weight,
    const Tensor& bias,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool transposed,
    IntArrayRef output_padding,
    int64_t groups);
std::tuple<Tensor, Tensor, Tensor> convolution_backward_overrideable(
    const Tensor& grad_output,
    const Tensor& input,
    const Tensor& weight,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool transposed,
    IntArrayRef output_padding,
    int64_t groups,
    std::array<bool, 3> output_mask);
Tensor conv_tbc(
    const Tensor& self,
    const Tensor& weight,
    const Tensor& bias,
    int64_t pad);
std::tuple<Tensor, Tensor, Tensor> conv_tbc_backward(
    const Tensor& self,
    const Tensor& input,
    const Tensor& weight,
    const Tensor& bias,
    int64_t pad);
Tensor& copy_(Tensor& self, const Tensor& src, bool non_blocking);
Tensor& cos_(Tensor& self);
Tensor& cos_out(Tensor& out, const Tensor& self);
Tensor& cosh_out(Tensor& out, const Tensor& self);
std::tuple<Tensor, Tensor> _ctc_loss(
    const Tensor& log_probs,
    const Tensor& targets,
    IntArrayRef input_lengths,
    IntArrayRef target_lengths,
    int64_t blank,
    bool zero_infinity);
Tensor _ctc_loss_backward(
    const Tensor& grad,
    const Tensor& log_probs,
    const Tensor& targets,
    IntArrayRef input_lengths,
    IntArrayRef target_lengths,
    const Tensor& neg_log_likelihood,
    const Tensor& log_alpha,
    int64_t blank,
    bool zero_infinity);
Tensor div(const Tensor& self, const Tensor& other);
Tensor& div_(Tensor& self, const Tensor& other);
Tensor& div_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor dot(const Tensor& self, const Tensor& tensor);
Tensor embedding_dense_backward(
    const Tensor& grad_output,
    const Tensor& indices,
    int64_t num_weights,
    int64_t padding_idx,
    bool scale_grad_by_freq);
std::tuple<Tensor, Tensor, Tensor, Tensor> _embedding_bag(
    const Tensor& weight,
    const Tensor& indices,
    const Tensor& offsets,
    bool scale_grad_by_freq,
    int64_t mode,
    bool sparse,
    const Tensor& per_sample_weights,
    bool include_last_offset);
Tensor _embedding_bag_dense_backward(
    const Tensor& grad,
    const Tensor& indices,
    const Tensor& offsets,
    const Tensor& offset2bag,
    const Tensor& bag_size,
    const Tensor& maximum_indices,
    int64_t num_weights,
    bool scale_grad_by_freq,
    int64_t mode,
    const Tensor& per_sample_weights);
Tensor empty(
    IntArrayRef size,
    const TensorOptions& options,
    c10::optional<MemoryFormat> memory_format);
Tensor _empty_affine_quantized(
    IntArrayRef size,
    const TensorOptions& options,
    double scale,
    int64_t zero_point,
    c10::optional<MemoryFormat> memory_format);
Tensor _empty_per_channel_affine_quantized(
    IntArrayRef size,
    const Tensor& scales,
    const Tensor& zero_points,
    int64_t axis,
    const TensorOptions& options,
    c10::optional<MemoryFormat> memory_format);
const Tensor& resize_(
    const Tensor& self,
    IntArrayRef size,
    c10::optional<MemoryFormat> memory_format);
Tensor empty_strided(
    IntArrayRef size,
    IntArrayRef stride,
    const TensorOptions& options);
Tensor& erf_(Tensor& self);
Tensor& erf_out(Tensor& out, const Tensor& self);
Tensor& erfc_(Tensor& self);
Tensor& erfc_out(Tensor& out, const Tensor& self);
Tensor& exp_(Tensor& self);
Tensor& exp_out(Tensor& out, const Tensor& self);
Tensor& expm1_out(Tensor& out, const Tensor& self);
Tensor& eye_out(Tensor& out, int64_t n);
Tensor& eye_out(Tensor& out, int64_t n, int64_t m);
Tensor& fill_(Tensor& self, Scalar value);
Tensor& fill_(Tensor& self, const Tensor& value);
Tensor& floor_out(Tensor& out, const Tensor& self);
Tensor floor_divide(const Tensor& self, const Tensor& other);
Tensor& floor_divide_(Tensor& self, const Tensor& other);
Tensor& floor_divide_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor frac(const Tensor& self);
Tensor& frac_(Tensor& self);
Tensor& frac_out(Tensor& out, const Tensor& self);
std::tuple<Tensor, Tensor, Tensor> native_group_norm(
    const Tensor& input,
    const Tensor& weight,
    const Tensor& bias,
    int64_t N,
    int64_t C,
    int64_t HxW,
    int64_t group,
    double eps);
std::tuple<Tensor, Tensor, Tensor> native_group_norm_backward(
    const Tensor& grad_out,
    const Tensor& input,
    const Tensor& mean,
    const Tensor& rstd,
    const Tensor& weight,
    int64_t N,
    int64_t C,
    int64_t HxW,
    int64_t group,
    std::array<bool, 3> output_mask);
Tensor _fft_with_size(
    const Tensor& self,
    int64_t signal_ndim,
    bool complex_input,
    bool complex_output,
    bool inverse,
    IntArrayRef checked_signal_sizes,
    int64_t normalization,
    bool onesided,
    IntArrayRef output_sizes);
Tensor index(const Tensor& self, TensorList indices);
Tensor& index_copy_(
    Tensor& self,
    int64_t dim,
    const Tensor& index,
    const Tensor& source);
Tensor& _index_put_impl_(
    Tensor& self,
    TensorList indices,
    const Tensor& values,
    bool accumulate,
    bool unsafe);
Tensor inverse(const Tensor& self);
Tensor& inverse_out(Tensor& out, const Tensor& self);
Tensor _inverse_helper(const Tensor& self);
Tensor isnan(const Tensor& self);
std::tuple<Tensor&, Tensor&> kthvalue_out(
    Tensor& values,
    Tensor& indices,
    const Tensor& self,
    int64_t k,
    int64_t dim,
    bool keepdim);
std::tuple<Tensor, Tensor, Tensor> native_layer_norm(
    const Tensor& input,
    const Tensor& weight,
    const Tensor& bias,
    int64_t M,
    int64_t N,
    double eps);
std::tuple<Tensor, Tensor, Tensor> native_layer_norm_backward(
    const Tensor& grad_out,
    const Tensor& input,
    const Tensor& mean,
    const Tensor& rstd,
    const Tensor& weight,
    int64_t M,
    int64_t N,
    std::array<bool, 3> output_mask);
Tensor& linspace_out(
    Tensor& out,
    Scalar start,
    Scalar end,
    c10::optional<int64_t> steps);
Tensor& log_out(Tensor& out, const Tensor& self);
Tensor& log10_out(Tensor& out, const Tensor& self);
Tensor& log1p_(Tensor& self);
Tensor& log1p_out(Tensor& out, const Tensor& self);
Tensor& log2_out(Tensor& out, const Tensor& self);
Tensor& logspace_out(
    Tensor& out,
    Scalar start,
    Scalar end,
    c10::optional<int64_t> steps,
    double base);
Tensor _log_softmax(const Tensor& self, int64_t dim, bool half_to_float);
Tensor _log_softmax_backward_data(
    const Tensor& grad_output,
    const Tensor& output,
    int64_t dim,
    const Tensor& self);
std::tuple<Tensor, Tensor> _aminmax(const Tensor& self);
std::tuple<Tensor, Tensor> _aminmax(
    const Tensor& self,
    int64_t dim,
    bool keepdim);
std::tuple<Tensor, Tensor> max(const Tensor& self, int64_t dim, bool keepdim);
std::tuple<Tensor&, Tensor&> max_out(
    Tensor& max,
    Tensor& max_values,
    const Tensor& self,
    int64_t dim,
    bool keepdim);
Tensor amax(const Tensor& self, IntArrayRef dim, bool keepdim);
Tensor& amax_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef dim,
    bool keepdim);
Tensor mean(const Tensor& self, c10::optional<ScalarType> dtype);
Tensor mean(
    const Tensor& self,
    IntArrayRef dim,
    bool keepdim,
    c10::optional<ScalarType> dtype);
Tensor& mean_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef dim,
    bool keepdim,
    c10::optional<ScalarType> dtype);
std::tuple<Tensor, Tensor> min(const Tensor& self, int64_t dim, bool keepdim);
std::tuple<Tensor&, Tensor&> min_out(
    Tensor& min,
    Tensor& min_indices,
    const Tensor& self,
    int64_t dim,
    bool keepdim);
Tensor mm(const Tensor& self, const Tensor& mat2);
Tensor& mm_out(Tensor& out, const Tensor& self, const Tensor& mat2);
std::tuple<Tensor, Tensor> mode(const Tensor& self, int64_t dim, bool keepdim);
std::tuple<Tensor&, Tensor&> mode_out(
    Tensor& values,
    Tensor& indices,
    const Tensor& self,
    int64_t dim,
    bool keepdim);
Tensor mul(const Tensor& self, const Tensor& other);
Tensor& mul_(Tensor& self, const Tensor& other);
Tensor& mul_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor mul(const Tensor& self, Scalar other);
Tensor& mul_(Tensor& self, Scalar other);
Tensor mv(const Tensor& self, const Tensor& vec);
Tensor mvlgamma(const Tensor& self, int64_t p);
Tensor& mvlgamma_(Tensor& self, int64_t p);
Tensor narrow_copy(
    const Tensor& self,
    int64_t dim,
    int64_t start,
    int64_t length);
std::tuple<Tensor, Tensor, Tensor> native_batch_norm(
    const Tensor& input,
    const Tensor& weight,
    const Tensor& bias,
    const Tensor& running_mean,
    const Tensor& running_var,
    bool training,
    double momentum,
    double eps);
std::tuple<Tensor, Tensor, Tensor> native_batch_norm_backward(
    const Tensor& grad_out,
    const Tensor& input,
    const Tensor& weight,
    const Tensor& running_mean,
    const Tensor& running_var,
    const Tensor& save_mean,
    const Tensor& save_invstd,
    bool train,
    double eps,
    std::array<bool, 3> output_mask);
Tensor _cdist_forward(
    const Tensor& x1,
    const Tensor& x2,
    double p,
    c10::optional<int64_t> compute_mode);
Tensor _cdist_backward(
    const Tensor& grad,
    const Tensor& x1,
    const Tensor& x2,
    double p,
    const Tensor& cdist);
Tensor _pdist_forward(const Tensor& self, double p);
Tensor _pdist_backward(
    const Tensor& grad,
    const Tensor& self,
    double p,
    const Tensor& pdist);
Tensor randperm(int64_t n, const TensorOptions& options);
Tensor randperm(
    int64_t n,
    c10::optional<Generator> generator,
    const TensorOptions& options);
Tensor& randperm_out(Tensor& out, int64_t n);
Tensor& randperm_out(
    Tensor& out,
    int64_t n,
    c10::optional<Generator> generator);
Tensor& range_out(Tensor& out, Scalar start, Scalar end, Scalar step);
Tensor& reciprocal_out(Tensor& out, const Tensor& self);
Tensor& neg_out(Tensor& out, const Tensor& self);
Tensor& round_out(Tensor& out, const Tensor& self);
Tensor rrelu(
    const Tensor& self,
    Scalar lower,
    Scalar upper,
    bool training,
    c10::optional<Generator> generator);
Tensor& rrelu_(
    Tensor& self,
    Scalar lower,
    Scalar upper,
    bool training,
    c10::optional<Generator> generator);
Tensor relu(const Tensor& self);
Tensor& relu_(Tensor& self);
Tensor prelu(const Tensor& self, const Tensor& weight);
std::tuple<Tensor, Tensor> prelu_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& weight);
Tensor gelu(const Tensor& self);
Tensor gelu_backward(const Tensor& grad, const Tensor& self);
Tensor hardshrink(const Tensor& self, Scalar lambd);
Tensor hardshrink_backward(
    const Tensor& grad_out,
    const Tensor& self,
    Scalar lambd);
Tensor& rsqrt_out(Tensor& out, const Tensor& self);
Tensor sigmoid(const Tensor& self);
Tensor& sigmoid_(Tensor& self);
Tensor& sigmoid_out(Tensor& out, const Tensor& self);
Tensor& sin_out(Tensor& out, const Tensor& self);
Tensor& sinh_out(Tensor& out, const Tensor& self);
Tensor slice(
    const Tensor& self,
    int64_t dim,
    int64_t start,
    int64_t end,
    int64_t step);
Tensor _softmax(const Tensor& self, int64_t dim, bool half_to_float);
Tensor _softmax_backward_data(
    const Tensor& grad_output,
    const Tensor& output,
    int64_t dim,
    const Tensor& self);
Tensor sum(const Tensor& self, c10::optional<ScalarType> dtype);
Tensor sum(
    const Tensor& self,
    IntArrayRef dim,
    bool keepdim,
    c10::optional<ScalarType> dtype);
Tensor& sum_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef dim,
    bool keepdim,
    c10::optional<ScalarType> dtype);
Tensor& sqrt_out(Tensor& out, const Tensor& self);
Tensor std(const Tensor& self, bool unbiased);
Tensor std(const Tensor& self, IntArrayRef dim, bool unbiased, bool keepdim);
std::tuple<Tensor, Tensor> std_mean(const Tensor& self, bool unbiased);
std::tuple<Tensor, Tensor> std_mean(
    const Tensor& self,
    IntArrayRef dim,
    bool unbiased,
    bool keepdim);
Tensor& std_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef dim,
    bool unbiased,
    bool keepdim);
Tensor prod(const Tensor& self, c10::optional<ScalarType> dtype);
Tensor prod(
    const Tensor& self,
    int64_t dim,
    bool keepdim,
    c10::optional<ScalarType> dtype);
Tensor& prod_out(
    Tensor& out,
    const Tensor& self,
    int64_t dim,
    bool keepdim,
    c10::optional<ScalarType> dtype);
Tensor& tan_(Tensor& self);
Tensor& tan_out(Tensor& out, const Tensor& self);
Tensor tanh(const Tensor& self);
Tensor& tanh_(Tensor& self);
Tensor& tanh_out(Tensor& out, const Tensor& self);
Tensor threshold(const Tensor& self, Scalar threshold, Scalar value);
Tensor& threshold_(Tensor& self, Scalar threshold, Scalar value);
Tensor& threshold_out(
    Tensor& out,
    const Tensor& self,
    Scalar threshold,
    Scalar value);
Tensor threshold_backward(
    const Tensor& grad_output,
    const Tensor& self,
    Scalar threshold);
Tensor flip(const Tensor& self, IntArrayRef dims);
Tensor roll(const Tensor& self, IntArrayRef shifts, IntArrayRef dims);
Tensor rot90(const Tensor& self, int64_t k, IntArrayRef dims);
Tensor& trunc_out(Tensor& out, const Tensor& self);
std::tuple<Tensor, Tensor> _unique(
    const Tensor& self,
    bool sorted,
    bool return_inverse);
std::tuple<Tensor, Tensor, Tensor> unique_dim(
    const Tensor& self,
    int64_t dim,
    bool sorted,
    bool return_inverse,
    bool return_counts);
std::tuple<Tensor, Tensor, Tensor> unique_consecutive(
    const Tensor& self,
    bool return_inverse,
    bool return_counts,
    c10::optional<int64_t> dim);
std::tuple<Tensor, Tensor, Tensor> unique_dim_consecutive(
    const Tensor& self,
    int64_t dim,
    bool return_inverse,
    bool return_counts);
std::tuple<Tensor, Tensor, Tensor> _unique2(
    const Tensor& self,
    bool sorted,
    bool return_inverse,
    bool return_counts);
Tensor var(const Tensor& self, bool unbiased);
Tensor var(const Tensor& self, IntArrayRef dim, bool unbiased, bool keepdim);
std::tuple<Tensor, Tensor> var_mean(const Tensor& self, bool unbiased);
std::tuple<Tensor, Tensor> var_mean(
    const Tensor& self,
    IntArrayRef dim,
    bool unbiased,
    bool keepdim);
Tensor _s_where(
    const Tensor& condition,
    const Tensor& self,
    const Tensor& other);
Tensor norm(const Tensor& self, c10::optional<Scalar> p, ScalarType dtype);
Tensor norm(const Tensor& self, Scalar p);
Tensor norm(
    const Tensor& self,
    c10::optional<Scalar> p,
    IntArrayRef dim,
    bool keepdim,
    ScalarType dtype);
Tensor norm(
    const Tensor& self,
    c10::optional<Scalar> p,
    IntArrayRef dim,
    bool keepdim);
Tensor& norm_out(
    Tensor& out,
    const Tensor& self,
    c10::optional<Scalar> p,
    IntArrayRef dim,
    bool keepdim,
    ScalarType dtype);
Tensor& norm_out(
    Tensor& out,
    const Tensor& self,
    c10::optional<Scalar> p,
    IntArrayRef dim,
    bool keepdim);
Tensor clone(const Tensor& self, c10::optional<MemoryFormat> memory_format);
const Tensor& resize_as_(
    const Tensor& self,
    const Tensor& the_template,
    c10::optional<MemoryFormat> memory_format);
Tensor& zero_(Tensor& self);
Tensor& sub_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& other,
    Scalar alpha);
Tensor sub(const Tensor& self, const Tensor& other, Scalar alpha);
Tensor& sub_(Tensor& self, const Tensor& other, Scalar alpha);
Tensor sub(const Tensor& self, Scalar other, Scalar alpha);
Tensor& sub_(Tensor& self, Scalar other, Scalar alpha);
Tensor rsub(const Tensor& self, const Tensor& other, Scalar alpha);
Tensor rsub(const Tensor& self, Scalar other, Scalar alpha);
Tensor addmm(
    const Tensor& self,
    const Tensor& mat1,
    const Tensor& mat2,
    Scalar beta,
    Scalar alpha);
Tensor& addmm_(
    Tensor& self,
    const Tensor& mat1,
    const Tensor& mat2,
    Scalar beta,
    Scalar alpha);
Tensor quantize_per_tensor(
    const Tensor& self,
    double scale,
    int64_t zero_point,
    ScalarType dtype);
Tensor quantize_per_channel(
    const Tensor& self,
    const Tensor& scales,
    const Tensor& zero_points,
    int64_t axis,
    ScalarType dtype);
Tensor dequantize(const Tensor& self);
Tensor _make_per_tensor_quantized_tensor(
    const Tensor& self,
    double scale,
    int64_t zero_point);
Tensor _make_per_channel_quantized_tensor(
    const Tensor& self,
    const Tensor& scale,
    const Tensor& zero_point,
    int64_t axis);
Scalar _local_scalar_dense(const Tensor& self);
Tensor& set_(Tensor& self, Storage source);
Tensor& set_(
    Tensor& self,
    Storage source,
    int64_t storage_offset,
    IntArrayRef size,
    IntArrayRef stride);
Tensor& set_(Tensor& self, const Tensor& source);
Tensor& set_(Tensor& self);
bool is_set_to(const Tensor& self, const Tensor& tensor);
Tensor& masked_fill_(Tensor& self, const Tensor& mask, Scalar value);
Tensor& masked_fill_(Tensor& self, const Tensor& mask, const Tensor& value);
Tensor& masked_scatter_(Tensor& self, const Tensor& mask, const Tensor& source);
Tensor view(const Tensor& self, IntArrayRef size);
Tensor& put_(
    Tensor& self,
    const Tensor& index,
    const Tensor& source,
    bool accumulate);
Tensor& index_add_(
    Tensor& self,
    int64_t dim,
    const Tensor& index,
    const Tensor& source);
Tensor& index_fill_(
    Tensor& self,
    int64_t dim,
    const Tensor& index,
    Scalar value);
Tensor& index_fill_(
    Tensor& self,
    int64_t dim,
    const Tensor& index,
    const Tensor& value);
Tensor& scatter_(
    Tensor& self,
    int64_t dim,
    const Tensor& index,
    const Tensor& src);
Tensor& scatter_(Tensor& self, int64_t dim, const Tensor& index, Scalar value);
Tensor& scatter_add_out(
    const Tensor& self,
    int64_t dim,
    const Tensor& index,
    const Tensor& src,
    Tensor& out);
Tensor& bitwise_and_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor& bitwise_and_out(Tensor& out, const Tensor& self, Scalar other);
Tensor& bitwise_or_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor& bitwise_or_out(Tensor& out, const Tensor& self, Scalar other);
Tensor& bitwise_xor_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor& bitwise_xor_out(Tensor& out, const Tensor& self, Scalar other);
Tensor& lgamma_(Tensor& self);
Tensor& atan2_(Tensor& self, const Tensor& other);
Tensor& tril_(Tensor& self, int64_t diagonal);
Tensor& triu_(Tensor& self, int64_t diagonal);
Tensor& digamma_(Tensor& self);
Tensor& polygamma_(Tensor& self, int64_t n);
Tensor& renorm_(Tensor& self, Scalar p, int64_t dim, Scalar maxnorm);
Tensor& pow_(Tensor& self, Scalar exponent);
Tensor& pow_(Tensor& self, const Tensor& exponent);
Tensor& lerp_(Tensor& self, const Tensor& end, Scalar weight);
Tensor& lerp_(Tensor& self, const Tensor& end, const Tensor& weight);
Tensor& fmod_(Tensor& self, Scalar other);
Tensor& fmod_(Tensor& self, const Tensor& other);
Tensor& remainder_(Tensor& self, Scalar other);
Tensor& remainder_(Tensor& self, const Tensor& other);
Tensor& addbmm_(
    Tensor& self,
    const Tensor& batch1,
    const Tensor& batch2,
    const Scalar& beta,
    const Scalar& alpha);
Tensor& addbmm_out(
    const Tensor& self,
    const Tensor& batch1,
    const Tensor& batch2,
    const Scalar& beta,
    const Scalar& alpha,
    Tensor& out);
Tensor addbmm(
    const Tensor& self,
    const Tensor& batch1,
    const Tensor& batch2,
    const Scalar& beta,
    const Scalar& alpha);
Tensor& addcdiv_(
    Tensor& self,
    const Tensor& tensor1,
    const Tensor& tensor2,
    Scalar value);
Tensor& random_(
    Tensor& self,
    int64_t from,
    c10::optional<int64_t> to,
    c10::optional<Generator> generator);
Tensor& random_(Tensor& self, int64_t to, c10::optional<Generator> generator);
Tensor& random_(Tensor& self, c10::optional<Generator> generator);
Tensor& uniform_(
    Tensor& self,
    double from,
    double to,
    c10::optional<Generator> generator);
Tensor& cauchy_(
    Tensor& self,
    double median,
    double sigma,
    c10::optional<Generator> generator);
Tensor& log_normal_(
    Tensor& self,
    double mean,
    double std,
    c10::optional<Generator> generator);
Tensor& exponential_(
    Tensor& self,
    double lambd,
    c10::optional<Generator> generator);
Tensor& geometric_(Tensor& self, double p, c10::optional<Generator> generator);
Tensor& diag_out(Tensor& out, const Tensor& self, int64_t diagonal);
Tensor diag(const Tensor& self, int64_t diagonal);
Tensor& cross_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& other,
    c10::optional<int64_t> dim);
Tensor cross(
    const Tensor& self,
    const Tensor& other,
    c10::optional<int64_t> dim);
Tensor& triu_out(Tensor& out, const Tensor& self, int64_t diagonal);
Tensor& tril_out(Tensor& out, const Tensor& self, int64_t diagonal);
Tensor tril_indices(
    int64_t row,
    int64_t col,
    int64_t offset,
    const TensorOptions& options);
Tensor triu_indices(
    int64_t row,
    int64_t col,
    int64_t offset,
    const TensorOptions& options);
Tensor trace(const Tensor& self);
Tensor& ne_out(Tensor& out, const Tensor& self, Scalar other);
Tensor ne(const Tensor& self, Scalar other);
Tensor& ne_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor ne(const Tensor& self, const Tensor& other);
Tensor& eq_out(Tensor& out, const Tensor& self, Scalar other);
Tensor eq(const Tensor& self, Scalar other);
Tensor& eq_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor eq(const Tensor& self, const Tensor& other);
Tensor& ge_out(Tensor& out, const Tensor& self, Scalar other);
Tensor ge(const Tensor& self, Scalar other);
Tensor& ge_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor ge(const Tensor& self, const Tensor& other);
Tensor& le_out(Tensor& out, const Tensor& self, Scalar other);
Tensor le(const Tensor& self, Scalar other);
Tensor& le_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor le(const Tensor& self, const Tensor& other);
Tensor& gt_out(Tensor& out, const Tensor& self, Scalar other);
Tensor gt(const Tensor& self, Scalar other);
Tensor& gt_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor gt(const Tensor& self, const Tensor& other);
Tensor& lt_out(Tensor& out, const Tensor& self, Scalar other);
Tensor lt(const Tensor& self, Scalar other);
Tensor& lt_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor lt(const Tensor& self, const Tensor& other);
Tensor& take_out(Tensor& out, const Tensor& self, const Tensor& index);
Tensor take(const Tensor& self, const Tensor& index);
Tensor& index_select_out(
    Tensor& out,
    const Tensor& self,
    int64_t dim,
    const Tensor& index);
Tensor index_select(const Tensor& self, int64_t dim, const Tensor& index);
Tensor& masked_select_out(Tensor& out, const Tensor& self, const Tensor& mask);
Tensor masked_select(const Tensor& self, const Tensor& mask);
Tensor& nonzero_out(Tensor& out, const Tensor& self);
Tensor nonzero(const Tensor& self);
Tensor& gather_out(
    Tensor& out,
    const Tensor& self,
    int64_t dim,
    const Tensor& index,
    bool sparse_grad);
Tensor gather(
    const Tensor& self,
    int64_t dim,
    const Tensor& index,
    bool sparse_grad);
Tensor& addcmul_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& tensor1,
    const Tensor& tensor2,
    Scalar value);
Tensor addcmul(
    const Tensor& self,
    const Tensor& tensor1,
    const Tensor& tensor2,
    Scalar value);
Tensor& addcmul_(
    Tensor& self,
    const Tensor& tensor1,
    const Tensor& tensor2,
    Scalar value);
Tensor& addcdiv_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& tensor1,
    const Tensor& tensor2,
    Scalar value);
Tensor addcdiv(
    const Tensor& self,
    const Tensor& tensor1,
    const Tensor& tensor2,
    Scalar value);
std::tuple<Tensor&, Tensor&> triangular_solve_out(
    Tensor& X,
    Tensor& M,
    const Tensor& self,
    const Tensor& A,
    bool upper,
    bool transpose,
    bool unitriangular);
std::tuple<Tensor, Tensor> triangular_solve(
    const Tensor& self,
    const Tensor& A,
    bool upper,
    bool transpose,
    bool unitriangular);
std::tuple<Tensor, Tensor> _triangular_solve_helper(
    const Tensor& self,
    const Tensor& A,
    bool upper,
    bool transpose,
    bool unitriangular);
std::tuple<Tensor, Tensor> _symeig_helper(
    const Tensor& self,
    bool eigenvectors,
    bool upper);
std::tuple<Tensor&, Tensor&, Tensor&> svd_out(
    Tensor& U,
    Tensor& S,
    Tensor& V,
    const Tensor& self,
    bool some,
    bool compute_uv);
std::tuple<Tensor, Tensor, Tensor> svd(
    const Tensor& self,
    bool some,
    bool compute_uv);
std::tuple<Tensor, Tensor, Tensor> _svd_helper(
    const Tensor& self,
    bool some,
    bool compute_uv);
Tensor& cholesky_out(Tensor& out, const Tensor& self, bool upper);
Tensor cholesky(const Tensor& self, bool upper);
Tensor& cholesky_solve_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& input2,
    bool upper);
Tensor cholesky_solve(const Tensor& self, const Tensor& input2, bool upper);
std::tuple<Tensor, Tensor> solve(const Tensor& self, const Tensor& A);
std::tuple<Tensor&, Tensor&> solve_out(
    Tensor& solution,
    Tensor& lu,
    const Tensor& self,
    const Tensor& A);
std::tuple<Tensor, Tensor> _solve_helper(const Tensor& self, const Tensor& A);
Tensor& cholesky_inverse_out(Tensor& out, const Tensor& self, bool upper);
Tensor cholesky_inverse(const Tensor& self, bool upper);
std::tuple<Tensor&, Tensor&> qr_out(
    Tensor& Q,
    Tensor& R,
    const Tensor& self,
    bool some);
std::tuple<Tensor, Tensor> qr(const Tensor& self, bool some);
std::tuple<Tensor, Tensor> _qr_helper(const Tensor& self, bool some);
std::tuple<Tensor&, Tensor&> geqrf_out(
    Tensor& a,
    Tensor& tau,
    const Tensor& self);
std::tuple<Tensor, Tensor> geqrf(const Tensor& self);
Tensor& orgqr_out(Tensor& out, const Tensor& self, const Tensor& input2);
Tensor orgqr(const Tensor& self, const Tensor& input2);
Tensor& ormqr_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& input2,
    const Tensor& input3,
    bool left,
    bool transpose);
Tensor ormqr(
    const Tensor& self,
    const Tensor& input2,
    const Tensor& input3,
    bool left,
    bool transpose);
std::tuple<Tensor, Tensor, Tensor> _lu_with_info(
    const Tensor& self,
    bool pivot,
    bool check_errors);
Tensor& lu_solve_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& LU_data,
    const Tensor& LU_pivots);
Tensor lu_solve(
    const Tensor& self,
    const Tensor& LU_data,
    const Tensor& LU_pivots);
Tensor _lu_solve_helper(
    const Tensor& self,
    const Tensor& LU_data,
    const Tensor& LU_pivots);
Tensor& multinomial_out(
    Tensor& out,
    const Tensor& self,
    int64_t num_samples,
    bool replacement,
    c10::optional<Generator> generator);
Tensor multinomial(
    const Tensor& self,
    int64_t num_samples,
    bool replacement,
    c10::optional<Generator> generator);
Tensor lgamma(const Tensor& self);
Tensor& digamma_out(Tensor& out, const Tensor& self);
Tensor digamma(const Tensor& self);
Tensor& polygamma_out(Tensor& out, int64_t n, const Tensor& self);
Tensor polygamma(int64_t n, const Tensor& self);
Tensor erfinv(const Tensor& self);
Tensor& erfinv_(Tensor& self);
Tensor& erfinv_out(Tensor& out, const Tensor& self);
Tensor sign(const Tensor& self);
Tensor& sign_(Tensor& self);
Tensor& sign_out(Tensor& out, const Tensor& self);
Tensor& atan2_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor atan2(const Tensor& self, const Tensor& other);
Tensor& lerp_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& end,
    Scalar weight);
Tensor& lerp_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& end,
    const Tensor& weight);
Tensor lerp(const Tensor& self, const Tensor& end, Scalar weight);
Tensor lerp(const Tensor& self, const Tensor& end, const Tensor& weight);
Tensor& histc_out(
    Tensor& out,
    const Tensor& self,
    int64_t bins,
    Scalar min,
    Scalar max);
Tensor histc(const Tensor& self, int64_t bins, Scalar min, Scalar max);
Tensor fmod(const Tensor& self, Scalar other);
Tensor fmod(const Tensor& self, const Tensor& other);
Tensor remainder(const Tensor& self, Scalar other);
Tensor remainder(const Tensor& self, const Tensor& other);
Tensor min(const Tensor& self);
Tensor max(const Tensor& self);
Tensor maximum(const Tensor& self, const Tensor& other);
Tensor& maximum_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor& max_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor minimum(const Tensor& self, const Tensor& other);
Tensor& minimum_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor& min_out(Tensor& out, const Tensor& self, const Tensor& other);
Tensor median(const Tensor& self);
std::tuple<Tensor&, Tensor&> sort_out(
    Tensor& values,
    Tensor& indices,
    const Tensor& self,
    int64_t dim,
    bool descending);
std::tuple<Tensor, Tensor> sort(
    const Tensor& self,
    int64_t dim,
    bool descending);
std::tuple<Tensor&, Tensor&> topk_out(
    Tensor& values,
    Tensor& indices,
    const Tensor& self,
    int64_t k,
    int64_t dim,
    bool largest,
    bool sorted);
std::tuple<Tensor, Tensor> topk(
    const Tensor& self,
    int64_t k,
    int64_t dim,
    bool largest,
    bool sorted);
Tensor all(const Tensor& self);
Tensor any(const Tensor& self);
Tensor& renorm_out(
    Tensor& out,
    const Tensor& self,
    Scalar p,
    int64_t dim,
    Scalar maxnorm);
Tensor renorm(const Tensor& self, Scalar p, int64_t dim, Scalar maxnorm);
Tensor unfold(
    const Tensor& self,
    int64_t dimension,
    int64_t size,
    int64_t step);
bool equal(const Tensor& self, const Tensor& other);
Tensor& pow_out(Tensor& out, const Tensor& self, const Tensor& exponent);
Tensor pow(const Tensor& self, const Tensor& exponent);
Tensor& pow_out(Tensor& out, Scalar self, const Tensor& exponent);
Tensor pow(Scalar self, const Tensor& exponent);
Tensor& pow_out(Tensor& out, const Tensor& self, Scalar exponent);
Tensor pow(const Tensor& self, Scalar exponent);
Tensor& normal_(
    Tensor& self,
    double mean,
    double std,
    c10::optional<Generator> generator);
Tensor& normal_out(
    Tensor& out,
    const Tensor& mean,
    double std,
    c10::optional<Generator> generator);
Tensor normal(
    const Tensor& mean,
    double std,
    c10::optional<Generator> generator);
Tensor& normal_out(
    Tensor& out,
    double mean,
    const Tensor& std,
    c10::optional<Generator> generator);
Tensor normal(
    double mean,
    const Tensor& std,
    c10::optional<Generator> generator);
Tensor& normal_out(
    Tensor& out,
    const Tensor& mean,
    const Tensor& std,
    c10::optional<Generator> generator);
Tensor normal(
    const Tensor& mean,
    const Tensor& std,
    c10::optional<Generator> generator);
Tensor _cumsum(const Tensor& self, int64_t dim);
Tensor& _cumsum_out(Tensor& out, const Tensor& self, int64_t dim);
Tensor _cumprod(const Tensor& self, int64_t dim);
Tensor& _cumprod_out(Tensor& out, const Tensor& self, int64_t dim);
Tensor _var(const Tensor& self, bool unbiased);
Tensor _std(const Tensor& self, bool unbiased);
Tensor _cat(TensorList tensors, int64_t dim);
Tensor& _cat_out(Tensor& out, TensorList tensors, int64_t dim);
Tensor& mse_loss_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor mse_loss(const Tensor& self, const Tensor& target, int64_t reduction);
Tensor& mse_loss_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor mse_loss_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor& l1_loss_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor l1_loss(const Tensor& self, const Tensor& target, int64_t reduction);
Tensor& l1_loss_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor l1_loss_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor& multi_margin_loss_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& target,
    Scalar p,
    Scalar margin,
    const Tensor& weight,
    int64_t reduction);
Tensor multi_margin_loss(
    const Tensor& self,
    const Tensor& target,
    Scalar p,
    Scalar margin,
    const Tensor& weight,
    int64_t reduction);
Tensor& multi_margin_loss_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    Scalar p,
    Scalar margin,
    const Tensor& weight,
    int64_t reduction);
Tensor multi_margin_loss_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    Scalar p,
    Scalar margin,
    const Tensor& weight,
    int64_t reduction);
std::tuple<Tensor&, Tensor&> multilabel_margin_loss_forward_out(
    Tensor& output,
    Tensor& is_target,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
std::tuple<Tensor, Tensor> multilabel_margin_loss_forward(
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor& multilabel_margin_loss_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction,
    const Tensor& is_target);
Tensor multilabel_margin_loss_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction,
    const Tensor& is_target);
std::tuple<Tensor&, Tensor&> nll_loss_forward_out(
    Tensor& output,
    Tensor& total_weight,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index);
std::tuple<Tensor, Tensor> nll_loss_forward(
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index);
Tensor& nll_loss_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index,
    const Tensor& total_weight);
Tensor nll_loss_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index,
    const Tensor& total_weight);
std::tuple<Tensor&, Tensor&> nll_loss2d_forward_out(
    Tensor& output,
    Tensor& total_weight,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index);
std::tuple<Tensor, Tensor> nll_loss2d_forward(
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index);
Tensor& nll_loss2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index,
    const Tensor& total_weight);
Tensor nll_loss2d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    const Tensor& weight,
    int64_t reduction,
    int64_t ignore_index,
    const Tensor& total_weight);
Tensor& smooth_l1_loss_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction,
    double beta);
Tensor smooth_l1_loss(
    const Tensor& self,
    const Tensor& target,
    int64_t reduction,
    double beta);
Tensor& smooth_l1_loss_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction,
    double beta);
Tensor smooth_l1_loss_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction,
    double beta);
Tensor& soft_margin_loss_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor soft_margin_loss(
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor& soft_margin_loss_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor soft_margin_loss_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& target,
    int64_t reduction);
Tensor& elu_out(
    Tensor& out,
    const Tensor& self,
    Scalar alpha,
    Scalar scale,
    Scalar input_scale);
Tensor elu(const Tensor& self, Scalar alpha, Scalar scale, Scalar input_scale);
Tensor& elu_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    Scalar alpha,
    Scalar scale,
    Scalar input_scale,
    const Tensor& output);
Tensor elu_backward(
    const Tensor& grad_output,
    Scalar alpha,
    Scalar scale,
    Scalar input_scale,
    const Tensor& output);
Tensor& elu_(Tensor& self, Scalar alpha, Scalar scale, Scalar input_scale);
Tensor& glu_out(Tensor& out, const Tensor& self, int64_t dim);
Tensor glu(const Tensor& self, int64_t dim);
Tensor& glu_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    int64_t dim);
Tensor glu_backward(const Tensor& grad_output, const Tensor& self, int64_t dim);
Tensor& hardtanh_out(
    Tensor& out,
    const Tensor& self,
    Scalar min_val,
    Scalar max_val);
Tensor hardtanh(const Tensor& self, Scalar min_val, Scalar max_val);
Tensor& hardtanh_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    Scalar min_val,
    Scalar max_val);
Tensor hardtanh_backward(
    const Tensor& grad_output,
    const Tensor& self,
    Scalar min_val,
    Scalar max_val);
Tensor& hardtanh_(Tensor& self, Scalar min_val, Scalar max_val);
Tensor& leaky_relu_out(Tensor& out, const Tensor& self, Scalar negative_slope);
Tensor leaky_relu(const Tensor& self, Scalar negative_slope);
Tensor leaky_relu_backward(
    const Tensor& grad_output,
    const Tensor& self,
    Scalar negative_slope,
    bool self_is_result);
Tensor& leaky_relu_(Tensor& self, Scalar negative_slope);
std::tuple<Tensor&, Tensor&> log_sigmoid_forward_out(
    Tensor& output,
    Tensor& buffer,
    const Tensor& self);
std::tuple<Tensor, Tensor> log_sigmoid_forward(const Tensor& self);
Tensor& log_sigmoid_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& buffer);
Tensor log_sigmoid_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& buffer);
Tensor& rrelu_with_noise_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& noise,
    Scalar lower,
    Scalar upper,
    bool training,
    c10::optional<Generator> generator);
Tensor rrelu_with_noise(
    const Tensor& self,
    const Tensor& noise,
    Scalar lower,
    Scalar upper,
    bool training,
    c10::optional<Generator> generator);
Tensor rrelu_with_noise_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& noise,
    Scalar lower,
    Scalar upper,
    bool training,
    bool self_is_result);
Tensor& rrelu_with_noise_(
    Tensor& self,
    const Tensor& noise,
    Scalar lower,
    Scalar upper,
    bool training,
    c10::optional<Generator> generator);
Tensor& softplus_out(
    Tensor& out,
    const Tensor& self,
    Scalar beta,
    Scalar threshold);
Tensor softplus(const Tensor& self, Scalar beta, Scalar threshold);
Tensor& softplus_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    Scalar beta,
    Scalar threshold,
    const Tensor& output);
Tensor softplus_backward(
    const Tensor& grad_output,
    const Tensor& self,
    Scalar beta,
    Scalar threshold,
    const Tensor& output);
Tensor& softshrink_out(Tensor& out, const Tensor& self, Scalar lambd);
Tensor softshrink(const Tensor& self, Scalar lambd);
Tensor& softshrink_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    Scalar lambd);
Tensor softshrink_backward(
    const Tensor& grad_output,
    const Tensor& self,
    Scalar lambd);
Tensor& adaptive_avg_pool2d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size);
Tensor _adaptive_avg_pool2d(const Tensor& self, IntArrayRef output_size);
Tensor _adaptive_avg_pool2d_backward(
    const Tensor& grad_output,
    const Tensor& self);
Tensor& adaptive_avg_pool3d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size);
Tensor adaptive_avg_pool3d(const Tensor& self, IntArrayRef output_size);
Tensor& adaptive_avg_pool3d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self);
Tensor adaptive_avg_pool3d_backward(
    const Tensor& grad_output,
    const Tensor& self);
std::tuple<Tensor&, Tensor&> adaptive_max_pool2d_out(
    Tensor& out,
    Tensor& indices,
    const Tensor& self,
    IntArrayRef output_size);
std::tuple<Tensor, Tensor> adaptive_max_pool2d(
    const Tensor& self,
    IntArrayRef output_size);
Tensor& adaptive_max_pool2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices);
Tensor adaptive_max_pool2d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices);
std::tuple<Tensor&, Tensor&> adaptive_max_pool3d_out(
    Tensor& out,
    Tensor& indices,
    const Tensor& self,
    IntArrayRef output_size);
std::tuple<Tensor, Tensor> adaptive_max_pool3d(
    const Tensor& self,
    IntArrayRef output_size);
Tensor& adaptive_max_pool3d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices);
Tensor adaptive_max_pool3d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices);
Tensor& avg_pool2d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
Tensor avg_pool2d(
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
Tensor& avg_pool2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
Tensor avg_pool2d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
Tensor& avg_pool3d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
Tensor avg_pool3d(
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
Tensor& avg_pool3d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
Tensor avg_pool3d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    bool ceil_mode,
    bool count_include_pad,
    c10::optional<int64_t> divisor_override);
std::tuple<Tensor&, Tensor&> fractional_max_pool2d_out(
    Tensor& output,
    Tensor& indices,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& random_samples);
std::tuple<Tensor, Tensor> fractional_max_pool2d(
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& random_samples);
Tensor& fractional_max_pool2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& indices);
Tensor fractional_max_pool2d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& indices);
std::tuple<Tensor&, Tensor&> fractional_max_pool3d_out(
    Tensor& output,
    Tensor& indices,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& random_samples);
std::tuple<Tensor, Tensor> fractional_max_pool3d(
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& random_samples);
Tensor& fractional_max_pool3d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& indices);
Tensor fractional_max_pool3d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef output_size,
    const Tensor& indices);
std::tuple<Tensor&, Tensor&> max_pool2d_with_indices_out(
    Tensor& out,
    Tensor& indices,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode);
std::tuple<Tensor, Tensor> max_pool2d_with_indices(
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode);
Tensor& max_pool2d_with_indices_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode,
    const Tensor& indices);
Tensor max_pool2d_with_indices_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode,
    const Tensor& indices);
std::tuple<Tensor&, Tensor&> max_pool3d_with_indices_out(
    Tensor& out,
    Tensor& indices,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode);
std::tuple<Tensor, Tensor> max_pool3d_with_indices(
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode);
Tensor& max_pool3d_with_indices_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode,
    const Tensor& indices);
Tensor max_pool3d_with_indices_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef stride,
    IntArrayRef padding,
    IntArrayRef dilation,
    bool ceil_mode,
    const Tensor& indices);
Tensor& max_unpool2d_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size);
Tensor max_unpool2d(
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size);
Tensor& max_unpool2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size);
Tensor max_unpool2d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size);
Tensor& max_unpool3d_out(
    Tensor& out,
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size,
    IntArrayRef stride,
    IntArrayRef padding);
Tensor max_unpool3d(
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size,
    IntArrayRef stride,
    IntArrayRef padding);
Tensor& max_unpool3d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size,
    IntArrayRef stride,
    IntArrayRef padding);
Tensor max_unpool3d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    const Tensor& indices,
    IntArrayRef output_size,
    IntArrayRef stride,
    IntArrayRef padding);
Tensor& reflection_pad1d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef padding);
Tensor reflection_pad1d(const Tensor& self, IntArrayRef padding);
Tensor& reflection_pad1d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef padding);
Tensor reflection_pad1d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef padding);
Tensor& replication_pad2d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef padding);
Tensor replication_pad2d(const Tensor& self, IntArrayRef padding);
Tensor& replication_pad2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef padding);
Tensor replication_pad2d_backward(
    const Tensor& grad_output,
    const Tensor& self,
    IntArrayRef padding);
Tensor upsample_linear1d(
    const Tensor& input,
    c10::optional<IntArrayRef> output_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_linear1d_backward(
    const Tensor& grad_output,
    c10::optional<IntArrayRef> output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_bilinear2d(
    const Tensor& input,
    c10::optional<IntArrayRef> output_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_bilinear2d_backward(
    const Tensor& grad_output,
    c10::optional<IntArrayRef> output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_trilinear3d(
    const Tensor& input,
    c10::optional<IntArrayRef> output_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_trilinear3d_backward(
    const Tensor& grad_output,
    c10::optional<IntArrayRef> output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_bicubic2d(
    const Tensor& input,
    c10::optional<IntArrayRef> output_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_bicubic2d_backward(
    const Tensor& grad_output,
    c10::optional<IntArrayRef> output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_nearest1d(
    const Tensor& input,
    c10::optional<IntArrayRef> output_size,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_nearest1d_backward(
    const Tensor& grad_output,
    c10::optional<IntArrayRef> output_size,
    IntArrayRef input_size,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_nearest2d(
    const Tensor& input,
    c10::optional<IntArrayRef> output_size,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_nearest2d_backward(
    const Tensor& grad_output,
    c10::optional<IntArrayRef> output_size,
    IntArrayRef input_size,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_nearest3d(
    const Tensor& input,
    c10::optional<IntArrayRef> output_size,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor upsample_nearest3d_backward(
    const Tensor& grad_output,
    c10::optional<IntArrayRef> output_size,
    IntArrayRef input_size,
    c10::optional<ArrayRef<double>> scale_factors);
Tensor& upsample_linear1d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales);
Tensor upsample_linear1d(
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales);
Tensor& upsample_linear1d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales);
Tensor upsample_linear1d_backward(
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales);
Tensor& upsample_bilinear2d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_bilinear2d(
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_bilinear2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_bilinear2d_backward(
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_bicubic2d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_bicubic2d(
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_bicubic2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_bicubic2d_backward(
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_trilinear3d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_trilinear3d(
    const Tensor& self,
    IntArrayRef output_size,
    bool align_corners,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_trilinear3d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_trilinear3d_backward(
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    bool align_corners,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_nearest1d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    c10::optional<double> scales);
Tensor upsample_nearest1d(
    const Tensor& self,
    IntArrayRef output_size,
    c10::optional<double> scales);
Tensor& upsample_nearest1d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    c10::optional<double> scales);
Tensor upsample_nearest1d_backward(
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    c10::optional<double> scales);
Tensor& upsample_nearest2d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_nearest2d(
    const Tensor& self,
    IntArrayRef output_size,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_nearest2d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_nearest2d_backward(
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_nearest3d_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_nearest3d(
    const Tensor& self,
    IntArrayRef output_size,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& upsample_nearest3d_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor upsample_nearest3d_backward(
    const Tensor& grad_output,
    IntArrayRef output_size,
    IntArrayRef input_size,
    c10::optional<double> scales_d,
    c10::optional<double> scales_h,
    c10::optional<double> scales_w);
Tensor& sigmoid_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& output);
Tensor sigmoid_backward(const Tensor& grad_output, const Tensor& output);
Tensor& tanh_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    const Tensor& output);
Tensor tanh_backward(const Tensor& grad_output, const Tensor& output);
Tensor& col2im_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef output_size,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
Tensor col2im(
    const Tensor& self,
    IntArrayRef output_size,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
Tensor& col2im_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
Tensor col2im_backward(
    const Tensor& grad_output,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
Tensor& im2col_out(
    Tensor& out,
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
Tensor im2col(
    const Tensor& self,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
Tensor& im2col_backward_out(
    Tensor& grad_input,
    const Tensor& grad_output,
    IntArrayRef input_size,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
Tensor im2col_backward(
    const Tensor& grad_output,
    IntArrayRef input_size,
    IntArrayRef kernel_size,
    IntArrayRef dilation,
    IntArrayRef padding,
    IntArrayRef stride);
void record_stream(Tensor& self, Stream s);
Tensor ger(const Tensor& self, const Tensor& vec2);
Tensor& ger_out(Tensor& out, const Tensor& self, const Tensor& vec2);
} // namespace AtenIpexTypeXPU

} // namespace at
