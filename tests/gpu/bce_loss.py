import torch
import torch.nn as nn

import torch_ipex

cpu_device = torch.device("cpu")
sycl_device = torch.device("dpcpp")

print('none')
loss = nn.BCELoss(reduction="none")
input = torch.tensor([0.2, 0.7, 0.9], requires_grad=True)
target = torch.tensor([0.5, 0.5, 0.5])

print("cpu")
output_cpu = loss(input, target)
print(output_cpu)
output_cpu.backward(torch.ones_like(target, dtype=torch.float))
print(input.grad)

print("sycl")
loss.to("dpcpp")
input_sycl = torch.tensor([0.2, 0.7, 0.9], device=sycl_device, requires_grad=True)
output_sycl = loss(input_sycl, target.to("dpcpp"))
print(output_sycl.to("cpu"))
output_sycl.backward(torch.ones_like(target, dtype=torch.float, device=sycl_device))
print(input_sycl.grad.to("cpu"))

print('none (weight)')
w = torch.tensor([0.2, 0.2, 0.2])
loss = nn.BCELoss(weight = w, reduction="none")
input = torch.tensor([0.2, 0.7, 0.9], requires_grad=True)
target = torch.tensor([0.5, 0.5, 0.5])

print("cpu")
output_cpu = loss(input, target)
print(output_cpu)
output_cpu.backward(torch.ones_like(target, dtype=torch.float))
print(input.grad)

print("sycl")
loss.to("dpcpp")
input_sycl = torch.tensor([0.2, 0.7, 0.9], device=sycl_device, requires_grad=True)
output_sycl = loss(input_sycl, target.to("dpcpp"))
print(output_sycl.to("cpu"))
output_sycl.backward(torch.ones_like(target, dtype=torch.float, device=sycl_device))
print(input_sycl.grad.to("cpu"))

print('sum')
loss = nn.BCELoss(reduction="sum")
input = torch.tensor([0.2, 0.7, 0.9], requires_grad=True)
target = torch.tensor([0.5, 0.5, 0.5])

print("cpu")
output_cpu = loss(input, target)
print(output_cpu)
output_cpu.backward(torch.tensor((2.0), dtype=torch.float))
print(input.grad)

print("sycl")
loss.to("dpcpp")
input_sycl = torch.tensor([0.2, 0.7, 0.9], device=sycl_device, requires_grad=True)
output_sycl = loss(input_sycl, target.to("dpcpp"))
print(output_sycl.to("cpu"))
output_sycl.backward(torch.tensor((2.0), dtype=torch.float, device=sycl_device))
print(input_sycl.grad.to("cpu"))


print('sum (weight)')
w = torch.tensor([0.2, 0.2, 0.2])
loss = nn.BCELoss(weight = w, reduction="sum")
input = torch.tensor([0.2, 0.7, 0.9], requires_grad=True)
target = torch.tensor([0.5, 0.5, 0.5])

print("cpu")
output_cpu = loss(input, target)
print(output_cpu)
output_cpu.backward(torch.tensor((0.5), dtype=torch.float))
print(input.grad)

print("sycl")
loss.to("dpcpp")
input_sycl = torch.tensor([0.2, 0.7, 0.9], device=sycl_device, requires_grad=True)
output_sycl = loss(input_sycl, target.to("dpcpp"))
print(output_sycl.to("cpu"))
output_sycl.backward(torch.tensor((0.5), dtype=torch.float, device=sycl_device))
print(input_sycl.grad.to("cpu"))

print('mean')
loss = nn.BCELoss(reduction="mean")
input = torch.tensor([0.2, 0.7, 0.9], requires_grad=True)
target = torch.tensor([0.5, 0.5, 0.5])

print("cpu")
output_cpu = loss(input, target)
print(output_cpu)
output_cpu.backward(torch.tensor((2.0), dtype=torch.float))
print(input.grad)

print("sycl")
loss.to("dpcpp")
input_sycl = torch.tensor([0.2, 0.7, 0.9], device=sycl_device, requires_grad=True)
output_sycl = loss(input_sycl, target.to("dpcpp"))
print(output_sycl.to("cpu"))
output_sycl.backward(torch.tensor((2.0), dtype=torch.float, device=sycl_device))
print(input_sycl.grad.to("cpu"))

print('mean (weight)')
w = torch.tensor([0.2, 0.2, 0.2])
loss = nn.BCELoss(weight=w, reduction="mean")
input = torch.tensor([0.2, 0.7, 0.9], requires_grad=True)
target = torch.tensor([0.5, 0.5, 0.5])

print("cpu")
output_cpu = loss(input, target)
print(output_cpu)
output_cpu.backward(torch.tensor((0.5), dtype=torch.float))
print(input.grad)

print("sycl")
loss.to("dpcpp")
input_sycl = torch.tensor([0.2, 0.7, 0.9], device=sycl_device, requires_grad=True)
output_sycl = loss(input_sycl, target.to("dpcpp"))
print(output_sycl.to("cpu"))
output_sycl.backward(torch.tensor((0.5), dtype=torch.float, device=sycl_device))
print(input_sycl.grad.to("cpu"))
