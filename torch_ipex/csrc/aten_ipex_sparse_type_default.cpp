// Autogenerated file by gen-cpu-sparse-dispatch.py. Do not edit directly!

#include <ATen/Context.h>
#include <ATen/core/op_registration/op_registration.h>
#include <ATen/CPUGenerator.h>
#include <c10/util/Exception.h>

#include "aten_ipex_sparse_type_default.h"
#include "aten_ipex_bridge.h"
#include "utils.h"
#include "cpu/SparseOPs.h"

namespace torch_ipex {

at::Tensor AtenIpexSparseTypeDefault::add(const at::Tensor & self, const at::Tensor & other, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::add(self, other, alpha);
}

at::Tensor & AtenIpexSparseTypeDefault::add_(at::Tensor & self, const at::Tensor & other, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::add_(self, other, alpha);
}

at::Tensor & AtenIpexSparseTypeDefault::add_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::add_out(out, self, other, alpha);
}

at::Tensor AtenIpexSparseTypeDefault::div(const at::Tensor & self, const at::Tensor & other) {
  return cpu::AtenIpexCPUSparse::div(self, other);
}

at::Tensor & AtenIpexSparseTypeDefault::div_(at::Tensor & self, const at::Tensor & other) {
  return cpu::AtenIpexCPUSparse::div_(self, other);
}

at::Tensor & AtenIpexSparseTypeDefault::div_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
  return cpu::AtenIpexCPUSparse::div_out(out, self, other);
}

at::Tensor AtenIpexSparseTypeDefault::empty(at::IntArrayRef size, const at::TensorOptions & options, c10::optional<at::MemoryFormat> memory_format) {
  return cpu::AtenIpexCPUSparse::empty(size, options, memory_format);
}

at::Tensor & AtenIpexSparseTypeDefault::log1p_(at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::log1p_(self);
}

at::Tensor & AtenIpexSparseTypeDefault::log1p_out(at::Tensor & out, const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::log1p_out(out, self);
}

at::Tensor AtenIpexSparseTypeDefault::mm(const at::Tensor & self, const at::Tensor & mat2) {
  return cpu::AtenIpexCPUSparse::mm(self, mat2);
}

at::Tensor & AtenIpexSparseTypeDefault::mm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat2) {
  return cpu::AtenIpexCPUSparse::mm_out(out, self, mat2);
}

at::Tensor AtenIpexSparseTypeDefault::mul(const at::Tensor & self, const at::Tensor & other) {
  return cpu::AtenIpexCPUSparse::mul(self, other);
}

at::Tensor & AtenIpexSparseTypeDefault::mul_(at::Tensor & self, const at::Tensor & other) {
  return cpu::AtenIpexCPUSparse::mul_(self, other);
}

at::Tensor & AtenIpexSparseTypeDefault::mul_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
  return cpu::AtenIpexCPUSparse::mul_out(out, self, other);
}

at::Tensor AtenIpexSparseTypeDefault::narrow_copy(const at::Tensor & self, int64_t dim, int64_t start, int64_t length) {
  return cpu::AtenIpexCPUSparse::narrow_copy(self, dim, start, length);
}

at::Tensor & AtenIpexSparseTypeDefault::sspaddmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, at::Scalar beta, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::sspaddmm_out(out, self, mat1, mat2, beta, alpha);
}

at::Tensor AtenIpexSparseTypeDefault::native_norm(const at::Tensor & self, at::Scalar p) {
  return cpu::AtenIpexCPUSparse::native_norm(self, p);
}

at::Tensor AtenIpexSparseTypeDefault::_sparse_sum_backward(const at::Tensor & grad, const at::Tensor & self, at::IntArrayRef dim) {
  return cpu::AtenIpexCPUSparse::_sparse_sum_backward(grad, self, dim);
}

at::Tensor AtenIpexSparseTypeDefault::clone(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format) {
  return cpu::AtenIpexCPUSparse::clone(self, memory_format);
}

at::Tensor & AtenIpexSparseTypeDefault::pow_out(at::Tensor & out, const at::Tensor & self, at::Scalar exponent) {
  return cpu::AtenIpexCPUSparse::pow_out(out, self, exponent);
}

at::Tensor AtenIpexSparseTypeDefault::pow(const at::Tensor & self, at::Scalar exponent) {
  return cpu::AtenIpexCPUSparse::pow(self, exponent);
}

at::Tensor & AtenIpexSparseTypeDefault::zero_(at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::zero_(self);
}

at::Tensor & AtenIpexSparseTypeDefault::sub_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::sub_out(out, self, other, alpha);
}

at::Tensor AtenIpexSparseTypeDefault::sub(const at::Tensor & self, const at::Tensor & other, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::sub(self, other, alpha);
}

at::Tensor & AtenIpexSparseTypeDefault::sub_(at::Tensor & self, const at::Tensor & other, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::sub_(self, other, alpha);
}

at::Tensor & AtenIpexSparseTypeDefault::addmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, at::Scalar beta, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::addmm_out(out, self, mat1, mat2, beta, alpha);
}

at::Tensor AtenIpexSparseTypeDefault::addmm(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, at::Scalar beta, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::addmm(self, mat1, mat2, beta, alpha);
}

at::Tensor & AtenIpexSparseTypeDefault::addmm_(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, at::Scalar beta, at::Scalar alpha) {
  return cpu::AtenIpexCPUSparse::addmm_(self, mat1, mat2, beta, alpha);
}

at::Tensor AtenIpexSparseTypeDefault::_sparse_coo_tensor_with_dims(int64_t sparse_dim, int64_t dense_dim, at::IntArrayRef size, const at::TensorOptions & options) {
  return cpu::AtenIpexCPUSparse::_sparse_coo_tensor_with_dims(sparse_dim, dense_dim, size, options);
}

at::Tensor AtenIpexSparseTypeDefault::_sparse_coo_tensor_with_dims_and_tensors(int64_t sparse_dim, int64_t dense_dim, at::IntArrayRef size, const at::Tensor & indices, const at::Tensor & values, const at::TensorOptions & options) {
  return cpu::AtenIpexCPUSparse::_sparse_coo_tensor_with_dims_and_tensors(sparse_dim, dense_dim, size, indices, values, options);
}

at::Tensor & AtenIpexSparseTypeDefault::sparse_resize_(at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
  return cpu::AtenIpexCPUSparse::sparse_resize_(self, size, sparse_dim, dense_dim);
}

at::Tensor & AtenIpexSparseTypeDefault::sparse_resize_and_clear_(at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
  return cpu::AtenIpexCPUSparse::sparse_resize_and_clear_(self, size, sparse_dim, dense_dim);
}

at::Tensor AtenIpexSparseTypeDefault::sparse_mask(const at::Tensor & self, const at::Tensor & mask) {
  return cpu::AtenIpexCPUSparse::sparse_mask(self, mask);
}

at::Tensor AtenIpexSparseTypeDefault::to_dense(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::to_dense(self);
}

int64_t AtenIpexSparseTypeDefault::sparse_dim(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::sparse_dim(self);
}

int64_t AtenIpexSparseTypeDefault::_dimI(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::_dimI(self);
}

int64_t AtenIpexSparseTypeDefault::dense_dim(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::dense_dim(self);
}

int64_t AtenIpexSparseTypeDefault::_dimV(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::_dimV(self);
}

int64_t AtenIpexSparseTypeDefault::_nnz(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::_nnz(self);
}

at::Tensor AtenIpexSparseTypeDefault::coalesce(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::coalesce(self);
}

bool AtenIpexSparseTypeDefault::is_coalesced(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::is_coalesced(self);
}

at::Tensor AtenIpexSparseTypeDefault::_indices(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::_indices(self);
}

at::Tensor AtenIpexSparseTypeDefault::_values(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::_values(self);
}

at::Tensor & AtenIpexSparseTypeDefault::_coalesced_(at::Tensor & self, bool coalesced) {
  return cpu::AtenIpexCPUSparse::_coalesced_(self, coalesced);
}

at::Tensor AtenIpexSparseTypeDefault::indices(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::indices(self);
}

at::Tensor AtenIpexSparseTypeDefault::values(const at::Tensor & self) {
  return cpu::AtenIpexCPUSparse::values(self);
}

at::Tensor & AtenIpexSparseTypeDefault::hspmm_out(at::Tensor & out, const at::Tensor & mat1, const at::Tensor & mat2) {
  return cpu::AtenIpexCPUSparse::hspmm_out(out, mat1, mat2);
}

at::Tensor AtenIpexSparseTypeDefault::hspmm(const at::Tensor & mat1, const at::Tensor & mat2) {
  return cpu::AtenIpexCPUSparse::hspmm(mat1, mat2);
}

at::Tensor & AtenIpexSparseTypeDefault::copy_sparse_to_sparse_(at::Tensor & self, const at::Tensor & src, bool non_blocking) {
  return cpu::AtenIpexCPUSparse::copy_sparse_to_sparse_(self, src, non_blocking);
}

at::Tensor AtenIpexSparseTypeDefault::index_select(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
  return cpu::AtenIpexCPUSparse::index_select(self, dim, index);
}



void RegisterAtenTypeSparseFunctions() {
  static auto dispatch = torch::RegisterOperators()
  .op(torch::RegisterOperators::options().schema("aten::add.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::add>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::add_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::add_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::add.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::add_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::div.Tensor(Tensor self, Tensor other) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::div>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::div_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::div_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::div.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::div_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::empty.memory_format(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(at::IntArrayRef, const at::TensorOptions &, c10::optional<at::MemoryFormat>), &AtenIpexSparseTypeDefault::empty>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::log1p_(Tensor(a!) self) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &), &AtenIpexSparseTypeDefault::log1p_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::log1p.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::log1p_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::mm(Tensor self, Tensor mat2) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::mm>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::mm.out(Tensor self, Tensor mat2, *, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::mm_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::mul.Tensor(Tensor self, Tensor other) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::mul>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::mul_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::mul_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::mul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::mul_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::narrow_copy(Tensor self, int dim, int start, int length) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, int64_t, int64_t, int64_t), &AtenIpexSparseTypeDefault::narrow_copy>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sspaddmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &, const at::Tensor &, at::Scalar, at::Scalar), &AtenIpexSparseTypeDefault::sspaddmm_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::native_norm(Tensor self, Scalar p=2) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::native_norm>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_sparse_sum_backward(Tensor grad, Tensor self, int[] dim) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &, at::IntArrayRef), &AtenIpexSparseTypeDefault::_sparse_sum_backward>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::clone(Tensor self, *, MemoryFormat? memory_format=None) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, c10::optional<at::MemoryFormat>), &AtenIpexSparseTypeDefault::clone>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::pow.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::pow_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::pow.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::pow>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::zero_(Tensor(a!) self) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &), &AtenIpexSparseTypeDefault::zero_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sub.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::sub_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sub.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::sub>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sub_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, at::Scalar), &AtenIpexSparseTypeDefault::sub_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &, const at::Tensor &, at::Scalar, at::Scalar), &AtenIpexSparseTypeDefault::addmm_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &, const at::Tensor &, at::Scalar, at::Scalar), &AtenIpexSparseTypeDefault::addmm>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &, at::Scalar, at::Scalar), &AtenIpexSparseTypeDefault::addmm_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_sparse_coo_tensor_with_dims(int sparse_dim, int dense_dim, int[] size, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(int64_t, int64_t, at::IntArrayRef, const at::TensorOptions &), &AtenIpexSparseTypeDefault::_sparse_coo_tensor_with_dims>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_sparse_coo_tensor_with_dims_and_tensors(int sparse_dim, int dense_dim, int[] size, Tensor indices, Tensor values, *, ScalarType dtype, Layout layout, Device device, bool pin_memory=False) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(int64_t, int64_t, at::IntArrayRef, const at::Tensor &, const at::Tensor &, const at::TensorOptions &), &AtenIpexSparseTypeDefault::_sparse_coo_tensor_with_dims_and_tensors>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sparse_resize_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, at::IntArrayRef, int64_t, int64_t), &AtenIpexSparseTypeDefault::sparse_resize_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sparse_resize_and_clear_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, at::IntArrayRef, int64_t, int64_t), &AtenIpexSparseTypeDefault::sparse_resize_and_clear_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sparse_mask(Tensor self, Tensor mask) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::sparse_mask>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::to_dense(Tensor self) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &), &AtenIpexSparseTypeDefault::to_dense>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::sparse_dim(Tensor self) -> int")
      .impl_unboxedOnlyKernel<int64_t(const at::Tensor &), &AtenIpexSparseTypeDefault::sparse_dim>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_dimI(Tensor self) -> int")
      .impl_unboxedOnlyKernel<int64_t(const at::Tensor &), &AtenIpexSparseTypeDefault::_dimI>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::dense_dim(Tensor self) -> int")
      .impl_unboxedOnlyKernel<int64_t(const at::Tensor &), &AtenIpexSparseTypeDefault::dense_dim>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_dimV(Tensor self) -> int")
      .impl_unboxedOnlyKernel<int64_t(const at::Tensor &), &AtenIpexSparseTypeDefault::_dimV>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_nnz(Tensor self) -> int")
      .impl_unboxedOnlyKernel<int64_t(const at::Tensor &), &AtenIpexSparseTypeDefault::_nnz>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::coalesce(Tensor self) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &), &AtenIpexSparseTypeDefault::coalesce>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::is_coalesced(Tensor self) -> bool")
      .impl_unboxedOnlyKernel<bool(const at::Tensor &), &AtenIpexSparseTypeDefault::is_coalesced>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_indices(Tensor(a) self) -> Tensor(a)")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &), &AtenIpexSparseTypeDefault::_indices>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_values(Tensor(a) self) -> Tensor(a)")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &), &AtenIpexSparseTypeDefault::_values>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::_coalesced_(Tensor(a!) self, bool coalesced) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, bool), &AtenIpexSparseTypeDefault::_coalesced_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::indices(Tensor(a) self) -> Tensor(a)")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &), &AtenIpexSparseTypeDefault::indices>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::values(Tensor(a) self) -> Tensor(a)")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &), &AtenIpexSparseTypeDefault::values>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::hspmm.out(Tensor mat1, Tensor mat2, *, Tensor(a!) out) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::hspmm_out>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::hspmm(Tensor mat1, Tensor mat2) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, const at::Tensor &), &AtenIpexSparseTypeDefault::hspmm>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::copy_sparse_to_sparse_(Tensor(a!) self, Tensor src, bool non_blocking=False) -> Tensor(a!)")
      .impl_unboxedOnlyKernel<at::Tensor &(at::Tensor &, const at::Tensor &, bool), &AtenIpexSparseTypeDefault::copy_sparse_to_sparse_>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
  .op(torch::RegisterOperators::options().schema("aten::index_select(Tensor self, int dim, Tensor index) -> Tensor")
      .impl_unboxedOnlyKernel<at::Tensor(const at::Tensor &, int64_t, const at::Tensor &), &AtenIpexSparseTypeDefault::index_select>(at::TensorTypeId::SparseDPCPPTensorId)
      .aliasAnalysis(c10::AliasAnalysisKind::FROM_SCHEMA))
;
}

}  // namespace torch_ipex

