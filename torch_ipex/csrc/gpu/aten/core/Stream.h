#pragma once

#include <cstdint>
#include <utility>

#include <c10/core/Stream.h>
#include <c10/util/Exception.h>

#include <core/DPCPPUtils.h>
#include <core/Macros.h>

/*
* Stream pool note.
*
* A DPCPPStream is an abstraction of an actual cuStream on the GPU. DPCPPStreams
* are backed by cuStreams, but they use several pools to minimize the costs
* associated with creating, retaining, and destroying cuStreams.
*
* There are three pools per device, and a device's pools are lazily created.
*
* The first pool contains only the default stream. When the default stream
* is requested it's returned.
*
* The second pool is the "low priority" or "default priority" streams. In
* HIP builds there is no distinction between streams in this pool and streams
* in the third pool (below). There are 32 of these streams per device, and
* when a stream is requested one of these streams is returned round-robin.
* That is, the first stream requested is at index 0, the second at index 1...
* to index 31, then index 0 again.
*
* This means that if 33 low priority streams are requested, the first and
* last streams requested are actually the same stream (under the covers)
* and kernels enqueued on them cannot run concurrently.
*
* The third pool is the "high priority" streams. The third pool acts like
* the second pool except the streams are created with a higher priority.
*
* These pools suggest that stream users should prefer many short-lived streams,
* as the cost of acquiring and releasing streams is effectively zero. If
* many longer-lived streams are required in performance critical scenarios
* then the functionality here may need to be extended to allow, for example,
* "reserving" a subset of the pool so that other streams do not accidentally
* overlap the performance critical streams.
*
* Note: although the notion of "current stream for device" is thread local
* (every OS thread has a separate current stream, as one might expect),
* the stream pool is global across all threads; stream 0 is always stream 0
* no matter which thread you use it on.  Multiple threads can synchronize
* on the same stream.  Although the DPCPP documentation is not very clear
* on the matter, streams are thread safe; e.g., it is safe to enqueue
* a kernel on the same stream from two different threads.
*/

namespace at {
namespace dpcpp {

#define dpcppStream_t unsigned long

#define DPCPP_STREAM_COMPUTATION_INDEX 0
#define DPCPP_STREAM_IO_INDEX 1
#define DPCPP_STREAM_NETWORK_INDEX 2
#define DPCPP_STREAM_MAX_INDEX 32

// Value object representing a DPCPP stream.  This is just a wrapper
// around c10::Stream, but it comes with a little extra DPCPP-specific
// functionality (conversion to dpcppStream_t), and a guarantee that
// the wrapped c10::Stream really is a DPCPP stream.
class AT_DPCPP_API DPCPPStream {
 public:
  enum Unchecked { UNCHECKED };

  /// Construct a DPCPPStream from a Stream.  This construction is checked,
  /// and will raise an error if the Stream is not, in fact, a DPCPP stream.
  explicit DPCPPStream(Stream stream) : stream_(stream) {
    TORCH_CHECK(stream_.device_type() == DeviceType::DPCPP);
  }

  /// Construct a DPCPPStream from a Stream with no error checking.
  /// This constructor uses the "named" constructor idiom, and can
  /// be invoked as: DPCPPStream(DPCPPStream::UNCHECKED, stream)
  explicit DPCPPStream(Unchecked, Stream stream) : stream_(stream) {}

  bool operator==(const DPCPPStream& other) const noexcept {
    return unwrap() == other.unwrap();
  }

  bool operator!=(const DPCPPStream& other) const noexcept {
    return unwrap() != other.unwrap();
  }

  /// Implicit conversion to Stream (a.k.a., forget that the stream is a
  /// DPCPP stream).
  operator Stream() const {
    return unwrap();
  }

  /// Get the DPCPP device index that this stream is associated with.
  DeviceIndex device_index() const {
    return stream_.device_index();
  }

  /// Get the full Device that this stream is associated with.  The Device
  /// is guaranteed to be a DPCPP device.
  Device device() const {
    return Device(DeviceType::DPCPP, device_index());
  }

  /// Return the stream ID corresponding to this particular stream.
  StreamId id() const {
    return stream_.id();
  }

  /// Explicit conversion to Stream.
  Stream unwrap() const {
    return stream_;
  }

  /// Reversibly pack a DPCPPStream into a uint64_t representation.  This may
  /// be helpful when storing a DPCPPStream in a C struct, where you cannot
  /// conveniently place the DPCPPStream object itself (which is morally
  /// equivalent, but unfortunately is not POD due to the fact that it
  /// has constructors.)
  ///
  /// The DPCPPStream can be unpacked using unpack().  The format of
  /// the uint64_t is unspecified and may be changed.
  uint64_t pack() const noexcept {
    return stream_.pack();
  }

  // Unpack a DPCPPStream from the uint64_t representation generated by pack().
  static DPCPPStream unpack(uint64_t bits) {
    return DPCPPStream(Stream::unpack(bits));
  }

  DPCPP::queue& dpcpp_queue() const;

  // Explicit conversion to dpcppStream_t
  dpcppStream_t stream() const {
    return (dpcppStream_t) this->dpcpp_queue().get();
  }

  // Deleted for now; use DPCPPEvent::block instead
  // void synchronize_with(const DPCPPEvent& event) const;

 private:
  Stream stream_;
};

CAFFE2_API DPCPPStream getDPCPPStreamFromPool(
    const bool isDefault = false,
    DeviceIndex device_index = -1);

CAFFE2_API DPCPPStream getDefaultDPCPPStream(DeviceIndex device_index = -1);

CAFFE2_API DPCPPStream getCurrentDPCPPStream(DeviceIndex device_index = -1);

CAFFE2_API void setCurrentDPCPPStream(DPCPPStream stream);

CAFFE2_API DPCPPStream
getDPCPPStreamOnDevice(DeviceIndex device_index, int stream_index);

C10_API std::ostream& operator<<(std::ostream& stream, const DPCPPStream& s);

} // namespace dpcpp
} // namespace at

namespace std {
template <>
struct hash<at::dpcpp::DPCPPStream> {
  size_t operator()(at::dpcpp::DPCPPStream s) const noexcept {
    return std::hash<c10::Stream>{}(s.unwrap());
  }
};
} // namespace std
