#include <ATen/LegacyTHFunctionsSYCL.h>

// @generated by aten/src/ATen/gen.py

#include <ATen/ATen.h>
#include <ATen/Utils.h>
#ifdef BUILD_NAMEDTENSOR
#include <ATen/NamedTensorUtils.h>
#endif
#include <ATen/ExpandUtils.h>
#include <legacy/THSYCL.h>
#include <legacy/THSYCLTensor.hpp>

#include <legacy_nn/THSYCLNN.h>
// #include <legacy/THSYCLNN.h>
#undef THNN_
#undef THSYCLIndexTensor_

#include <aten_ipex_tensor_type.h>

#include <core/TensorImplUtils.h>
#include <core/SYCLState.h>
#include <core/SYCLGenerator.h>
#include <core/SYCLDevice.h>
#include <core/SYCLContext.h>


namespace at {
namespace native {
namespace legacy {
namespace sycl {

namespace {
  static inline TensorImpl* checked_tensor_unwrap(const Tensor& expr, const char * name, int pos, const char * api, bool allowNull, Backend backend, ScalarType scalar_type) {
    if(allowNull && !expr.defined()) {
      return nullptr;
    }
    if (tensorTypeIdToBackend(legacyExtractTypeId(expr)) != backend) {
      AT_ERROR("Expected object of backend ", backend, " but got backend ", tensorTypeIdToBackend(legacyExtractTypeId(expr)),
               " for argument #", pos, " '", name, "' in call to ", api);
    }
    if (expr.scalar_type() != scalar_type) {
      AT_ERROR("Expected object of scalar type ", scalar_type, " but got scalar type ", expr.scalar_type(),
               " for argument #", pos, " '", name, "' in call to ", api);
    }
    // if (expr.is_variable()) {  // TODO: change this to check `.requires_grad()` and `GradMode::is_enabled()` when Variable and Tensor are merged
    //   AT_ERROR("Expected Tensor (not Variable) for argument #", pos, " '", name, "' in call to ", api);
    // }
    return expr.unsafeGetTensorImpl();
  }
  ScalarType infer_scalar_type(const Tensor & t) {
    return t.scalar_type();
  }
  ScalarType infer_scalar_type(const TensorList & tl) {
    TORCH_CHECK(tl.size() > 0, "expected a non-empty list of Tensors");
    return tl[0].scalar_type();
  }

  TensorOptions options(ScalarType s) {
    return TensorOptions().dtype(s)
                          .device(DeviceType::DPCPP)
                          .layout(kStrided);
  }

  Allocator* allocator() {
    return at::sycl::getSYCLDeviceAllocator();
  }
}

Tensor & _th_set_(Tensor & self, Storage source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Bool));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Byte));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Char);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Char));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Double);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Double));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Float);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Float));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Int);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Int));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Long));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Short);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Short));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Half);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Half));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), 0, {static_cast<int64_t>(source.size())}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_set_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_set_(Tensor & self, Storage source, int64_t storage_offset, IntArrayRef size, IntArrayRef stride) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Bool));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Byte));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Char);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Char));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Double);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Double));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Float);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Float));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Int);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Int));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Long));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Short);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Short));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Half);
            auto source_ = checked_storage(source, "source", 2, DeviceType::DPCPP, at::scalarTypeToTypeMeta(ScalarType::Half));
            TensorImpl_setStorage(self_, source_.unsafeGetStorageImpl(), storage_offset, size, stride);
            self_->maybe_zero_dim(size.size() == 0);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_set_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_set_(Tensor & self, const Tensor & source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Bool);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Byte);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Char);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Char);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Double);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Double);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Float);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Float);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Int);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Int);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Long);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Short);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Short);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Half);
            auto source_ = checked_tensor_unwrap(source, "source", 2, "_th_set_", false, Backend::DPCPP, ScalarType::Half);
            TensorImpl_set(self_, source_);
            self_->maybe_zero_dim(source_->dim() == 0);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_set_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_set_(Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Bool);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Byte);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Char);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Double);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Float);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Int);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Long);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Short);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_set_", false, Backend::DPCPP, ScalarType::Half);
            TensorImpl_setStorage(self_, NULL, 0, {0}, {});
            self_->maybe_zero_dim(false);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_set_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_fill_(Tensor & self, Scalar value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toByte();
            THSyclByteTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Char);
            auto value_ = value.toChar();
            THSyclCharTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Double);
            auto value_ = value.toDouble();
            THSyclDoubleTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Float);
            auto value_ = value.toFloat();
            THSyclTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Int);
            auto value_ = value.toInt();
            THSyclIntTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toLong();
            THSyclLongTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Short);
            auto value_ = value.toShort();
            THSyclShortTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fill_", false, Backend::DPCPP, ScalarType::Half);
            auto value_ = value.toHalf();
            THSyclHalfTensor_fill(getTHSYCLState(), self_, value_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_fill_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_fill_(Tensor & self, const Tensor & value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    if (value.dim() == 0) {
        return _th_fill_(self, value.item());
    }
    AT_ERROR("_th_fill_ only supports a 0-dimensional value tensor, but got tensor "
        "with ", value.dim(), " dimension(s).");
}
bool _th_is_set_to(const Tensor & self, const Tensor & tensor) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Byte);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Byte);
            return THSyclByteTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Char);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Char);
            return THSyclCharTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Double);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Double);
            return THSyclDoubleTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Float);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Float);
            return THSyclTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Int);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Int);
            return THSyclIntTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Long);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Long);
            return THSyclLongTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Short);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Short);
            return THSyclShortTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Half);
            auto tensor_ = checked_tensor_unwrap(tensor, "tensor", 2, "_th_is_set_to", false, Backend::DPCPP, ScalarType::Half);
            return THSyclHalfTensor_isSetTo(getTHSYCLState(), self_, tensor_);
            break;
        }
        default:
            AT_ERROR("_th_is_set_to not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_masked_fill_(Tensor & self, const Tensor & mask, Scalar value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_fill_");
    return s__th_masked_fill_(self, b_mask, value);
}
Tensor & s__th_masked_fill_(Tensor & self, const Tensor & mask, Scalar value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toByte();
            THSyclByteTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toChar();
            THSyclCharTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toDouble();
            THSyclDoubleTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toFloat();
            THSyclTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toInt();
            THSyclIntTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toLong();
            THSyclLongTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toShort();
            THSyclShortTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_", false, Backend::DPCPP, ScalarType::Byte);
            auto value_ = value.toHalf();
            THSyclHalfTensor_maskedFill(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_masked_fill_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_masked_fill_(Tensor & self, const Tensor & mask, const Tensor & value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_fill_");
    return s__th_masked_fill_(self, b_mask, value);
}
Tensor & s__th_masked_fill_(Tensor & self, const Tensor & mask, const Tensor & value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    if (value.dim() == 0) {
        return _th_masked_fill_(self, mask, value.item());
    }
    AT_ERROR("_th_masked_fill_ only supports a 0-dimensional value tensor, but got tensor "
        "with ", value.dim(), " dimension(s).");
}
Tensor & _th_masked_fill_bool_(Tensor & self, const Tensor & mask, Scalar value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_fill_bool_");
    return s__th_masked_fill_bool_(self, b_mask, value);
}
Tensor & s__th_masked_fill_bool_(Tensor & self, const Tensor & mask, Scalar value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toByte();
            THSyclByteTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toChar();
            THSyclCharTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toDouble();
            THSyclDoubleTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toFloat();
            THSyclTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toInt();
            THSyclIntTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toLong();
            THSyclLongTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toShort();
            THSyclShortTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_fill_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto value_ = value.toHalf();
            THSyclHalfTensor_maskedFillBool(getTHSYCLState(), self_, mask_, value_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_masked_fill_bool_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_masked_fill_bool_(Tensor & self, const Tensor & mask, const Tensor & value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_fill_bool_");
    return s__th_masked_fill_bool_(self, b_mask, value);
}
Tensor & s__th_masked_fill_bool_(Tensor & self, const Tensor & mask, const Tensor & value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    if (value.dim() == 0) {
        return _th_masked_fill_bool_(self, mask, value.item());
    }
    AT_ERROR("_th_masked_fill_bool_ only supports a 0-dimensional value tensor, but got tensor "
        "with ", value.dim(), " dimension(s).");
}
Tensor & _th_masked_scatter_(Tensor & self, const Tensor & mask, const Tensor & source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_scatter_");
    return s__th_masked_scatter_(self, b_mask, source);
}
Tensor & s__th_masked_scatter_(Tensor & self, const Tensor & mask, const Tensor & source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_maskedCopy(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_masked_scatter_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_masked_scatter_bool_(Tensor & self, const Tensor & mask, const Tensor & source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_mask;
    std::tie(b_mask) = expand_inplace(self, mask, "_th_masked_scatter_bool_");
    return s__th_masked_scatter_bool_(self, b_mask, source);
}
Tensor & s__th_masked_scatter_bool_(Tensor & self, const Tensor & mask, const Tensor & source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Bool);
            auto source_ = checked_tensor_unwrap(source, "source", 3, "_th_masked_scatter_bool_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_maskedCopyBool(getTHSYCLState(), self_, mask_, source_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_masked_scatter_bool_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_masked_select_out(Tensor & result, const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_mask;
    std::tie(b_self, b_mask) = expand_outplace(self, mask, "_th_masked_select_out");
    return s__th_masked_select_out(result, b_self, b_mask);
}
Tensor & s__th_masked_select_out(Tensor & result, const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclCharTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclDoubleTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclIntTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclLongTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclShortTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclHalfTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_masked_select_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_masked_select(const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_mask;
    std::tie(b_self, b_mask) = expand_outplace(self, mask, "_th_masked_select");
    return s__th_masked_select(b_self, b_mask);
}
Tensor s__th_masked_select(const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclCharTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclDoubleTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclIntTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclLongTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclShortTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select", false, Backend::DPCPP, ScalarType::Byte);
            THSyclHalfTensor_maskedSelect(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_masked_select not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_masked_select_bool_out(Tensor & result, const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_mask;
    std::tie(b_self, b_mask) = expand_outplace(self, mask, "_th_masked_select_bool_out");
    return s__th_masked_select_bool_out(result, b_self, b_mask);
}
Tensor & s__th_masked_select_bool_out(Tensor & result, const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclByteTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclCharTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclDoubleTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclIntTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclLongTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclShortTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclHalfTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_masked_select_bool_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_masked_select_bool(const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_mask;
    std::tie(b_self, b_mask) = expand_outplace(self, mask, "_th_masked_select_bool");
    return s__th_masked_select_bool(b_self, b_mask);
}
Tensor s__th_masked_select_bool(const Tensor & self, const Tensor & mask) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Byte);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclByteTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Char);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclCharTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Double);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclDoubleTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Float);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Int);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclIntTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Long);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclLongTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Short);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclShortTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Half);
            auto mask_ = checked_tensor_unwrap(mask, "mask", 2, "_th_masked_select_bool", false, Backend::DPCPP, ScalarType::Bool);
            THSyclHalfTensor_maskedSelectBool(getTHSYCLState(), result_, self_, mask_);
            result_->maybe_zero_dim(self_->dim() == 0 && mask_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_masked_select_bool not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_nonzero_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_nonzero_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_nonzero(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_nonzero", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_nonzero(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_nonzero not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_clone(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Byte);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclByteTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Char);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclCharTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Double);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclDoubleTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Float);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Int);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclIntTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Long);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclLongTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Short);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclShortTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clone", false, Backend::DPCPP, ScalarType::Half);
            return Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim((THSyclHalfTensor_newClone(getTHSYCLState(), self_))->maybe_zero_dim(self_->dim() == 0)));
            break;
        }
        default:
            AT_ERROR("_th_clone not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_resize_as_(Tensor & self, const Tensor & the_template) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Byte);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Char);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Double);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Float);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Int);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Long);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Short);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Half);
            auto the_template_ = checked_tensor_unwrap(the_template, "the_template", 2, "_th_resize_as_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_resizeAs(getTHSYCLState(), self_, the_template_);
            self_->maybe_zero_dim(the_template_->dim() == 0);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_resize_as_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_index_select_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Bool);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclBoolTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclByteTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclCharTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclDoubleTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclIntTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclShortTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclHalfTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_index_select_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_index_select(const Tensor & self, int64_t dim, const Tensor & index) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Bool);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclBoolTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclByteTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclCharTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclDoubleTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclIntTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclShortTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_select", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_select", false, Backend::DPCPP, ScalarType::Long);
            THSyclHalfTensor_indexSelect(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_index_select not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_index_copy_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_copy_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_indexCopy(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_index_copy_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_take_out(Tensor & result, const Tensor & self, const Tensor & index) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Byte);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclByteTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Char);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclCharTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Double);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclDoubleTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Float);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Int);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclIntTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Short);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclShortTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_take_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take_out", false, Backend::DPCPP, ScalarType::Half);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclHalfTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_take_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_take(const Tensor & self, const Tensor & index) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Byte);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclByteTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Char);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclCharTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Double);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclDoubleTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Float);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Int);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclIntTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Short);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclShortTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_take", false, Backend::DPCPP, ScalarType::Half);
            auto index_ = checked_tensor_unwrap(index, "index", 2, "_th_take", false, Backend::DPCPP, ScalarType::Long);
            THSyclHalfTensor_take(getTHSYCLState(), result_, self_, index_);
            result_->maybe_zero_dim(index_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_take not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_index_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & source) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_add_", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_add_", false, Backend::DPCPP, ScalarType::Long);
            auto source_ = checked_tensor_unwrap(source, "source", 4, "_th_index_add_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_indexAdd(getTHSYCLState(), self_, dim, index_, source_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_index_add_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_index_fill_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toByte();
            THSyclByteTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toChar();
            THSyclCharTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toDouble();
            THSyclDoubleTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toFloat();
            THSyclTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toInt();
            THSyclIntTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toLong();
            THSyclLongTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toShort();
            THSyclShortTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_index_fill_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toHalf();
            THSyclHalfTensor_indexFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_index_fill_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_index_fill_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    if (value.dim() == 0) {
        return _th_index_fill_(self, dim, index, value.item());
    }
    AT_ERROR("_th_index_fill_ only supports a 0-dimensional value tensor, but got tensor "
        "with ", value.dim(), " dimension(s).");
}
Tensor & _th_unfold_out(Tensor & result, const Tensor & self, int64_t dimension, int64_t size, int64_t step) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Byte);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclByteTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Char);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclCharTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Double);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclDoubleTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Float);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Int);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclIntTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Long);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclLongTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Short);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclShortTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold_out", false, Backend::DPCPP, ScalarType::Half);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclHalfTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_unfold_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_unfold(const Tensor & self, int64_t dimension, int64_t size, int64_t step) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Byte);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclByteTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Char);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclCharTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Double);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclDoubleTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Float);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Int);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclIntTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Long);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclLongTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Short);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclShortTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_unfold", false, Backend::DPCPP, ScalarType::Half);
            dimension = maybe_wrap_dim(dimension, self_);
            THSyclHalfTensor_unfold(getTHSYCLState(), result_, self_, dimension, size, step);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_unfold not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_scatter_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    if (src.dim() == 0) {
        return _th_scatter_(self, dim, index, src.item());
    }
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_scatter(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_scatter_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_scatter_(Tensor & self, int64_t dim, const Tensor & index, Scalar value) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toByte();
            THSyclByteTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toChar();
            THSyclCharTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toDouble();
            THSyclDoubleTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toFloat();
            THSyclTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toInt();
            THSyclIntTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toLong();
            THSyclLongTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toShort();
            THSyclShortTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_", false, Backend::DPCPP, ScalarType::Long);
            auto value_ = value.toHalf();
            THSyclHalfTensor_scatterFill(getTHSYCLState(), self_, dim, index_, value_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_scatter_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_scatter_add_(Tensor & self, int64_t dim, const Tensor & index, const Tensor & src) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 4, "_th_scatter_add_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_scatterAdd(getTHSYCLState(), self_, dim, index_, src_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_scatter_add_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_gather_out(Tensor & result, const Tensor & self, int64_t dim, const Tensor & index) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Bool);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Bool);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclBoolTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Byte);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclByteTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Char);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclCharTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Double);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclDoubleTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Float);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Int);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclIntTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Short);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclShortTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gather_out", false, Backend::DPCPP, ScalarType::Half);
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclHalfTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gather_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_gather(const Tensor & self, int64_t dim, const Tensor & index) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Bool);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclBoolTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclByteTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclCharTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclDoubleTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclIntTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclShortTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_(index.sizes());
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gather", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            auto index_ = checked_tensor_unwrap(index, "index", 3, "_th_gather", false, Backend::DPCPP, ScalarType::Long);
            THSyclHalfTensor_gather(getTHSYCLState(), result_, self_, dim, index_);
            result_->maybe_zero_dim(self_->dim() == 0 && index_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gather not supported on SYCLType for ", dispatch_scalar_type);
    }
}
bool _th_equal(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Bool);
            return THSyclBoolTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Byte);
            return THSyclByteTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Char);
            return THSyclCharTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Double);
            return THSyclDoubleTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Float);
            return THSyclTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Int);
            return THSyclIntTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Long);
            return THSyclLongTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Short);
            return THSyclShortTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_equal", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_equal", false, Backend::DPCPP, ScalarType::Half);
            return THSyclHalfTensor_equal(getTHSYCLState(), self_, other_);
            break;
        }
        default:
            AT_ERROR("_th_equal not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_and_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_and_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_and(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_and not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_and_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_and_out");
    return s__th_and_out(result, b_self, b_other);
}
Tensor & s__th_and_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_and_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_and_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_and(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_and");
    return s__th_and(b_self, b_other);
}
Tensor s__th_and(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_and", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_and", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitand(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_and not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_iand_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_iand_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_iand_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_iand_");
    return s__th_iand_(self, b_other);
}
Tensor & s__th_iand_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_iand_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_iand_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitand(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_iand_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_or_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_or_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_or(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_or not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_or_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_or_out");
    return s__th_or_out(result, b_self, b_other);
}
Tensor & s__th_or_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_or_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_or_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_or(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_or");
    return s__th_or(b_self, b_other);
}
Tensor s__th_or(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_or", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_or", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_or not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ior_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ior_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ior_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_ior_");
    return s__th_ior_(self, b_other);
}
Tensor & s__th_ior_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ior_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ior_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ior_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_xor_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_xor_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_xor(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_xor not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_xor_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_xor_out");
    return s__th_xor_out(result, b_self, b_other);
}
Tensor & s__th_xor_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_xor_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_xor_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_xor(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_xor");
    return s__th_xor(b_self, b_other);
}
Tensor s__th_xor(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_xor", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_xor", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitxor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_xor not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ixor_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_bitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ixor_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ixor_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_ixor_");
    return s__th_ixor_(self, b_other);
}
Tensor & s__th_ixor_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ixor_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ixor_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cbitxor(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ixor_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lshift_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lshift_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_lshift(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_lshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lshift not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lshift_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lshift_out");
    return s__th_lshift_out(result, b_self, b_other);
}
Tensor & s__th_lshift_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lshift_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_lshift(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lshift");
    return s__th_lshift(b_self, b_other);
}
Tensor s__th_lshift(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lshift", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lshift", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_clshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lshift not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ilshift_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_lshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ilshift_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ilshift_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_ilshift_");
    return s__th_ilshift_(self, b_other);
}
Tensor & s__th_ilshift_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ilshift_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_clshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ilshift_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_rshift_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_rshift_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_rshift(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_rshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_rshift not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_rshift_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_rshift_out");
    return s__th_rshift_out(result, b_self, b_other);
}
Tensor & s__th_rshift_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_rshift_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_rshift(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_rshift");
    return s__th_rshift(b_self, b_other);
}
Tensor s__th_rshift(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rshift", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_rshift", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_crshift(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_rshift not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_irshift_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_rshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_irshift_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_irshift_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_irshift_");
    return s__th_irshift_(self, b_other);
}
Tensor & s__th_irshift_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_irshift_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_irshift_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_crshift(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_irshift_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lt_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_lt(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_ltValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lt_out");
    return s__th_lt_out(result, b_self, b_other);
}
Tensor & s__th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_lt(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lt");
    return s__th_lt(b_self, b_other);
}
Tensor s__th_lt(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_ltTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lt_byte_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_lt_byte(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_ltValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lt_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lt_byte_out");
    return s__th_lt_byte_out(result, b_self, b_other);
}
Tensor & s__th_lt_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_lt_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_lt_byte");
    return s__th_lt_byte(b_self, b_other);
}
Tensor s__th_lt_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_lt_byte", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_ltTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_lt_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lt_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_ltValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_lt_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_lt_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_lt_");
    return s__th_lt_(self, b_other);
}
Tensor & s__th_lt_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_lt_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_lt_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_ltTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_lt_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_gt_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_gt(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_gtValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_gt_out");
    return s__th_gt_out(result, b_self, b_other);
}
Tensor & s__th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_gt(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_gt");
    return s__th_gt(b_self, b_other);
}
Tensor s__th_gt(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_gtTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_gt_byte_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_gt_byte(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_gtValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_gt_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_gt_byte_out");
    return s__th_gt_byte_out(result, b_self, b_other);
}
Tensor & s__th_gt_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_gt_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_gt_byte");
    return s__th_gt_byte(b_self, b_other);
}
Tensor s__th_gt_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_gt_byte", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_gtTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_gt_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_gt_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_gtValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_gt_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_gt_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_gt_");
    return s__th_gt_(self, b_other);
}
Tensor & s__th_gt_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_gt_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_gt_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_gtTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_gt_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_le_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_le(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_leValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_le_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_le_out");
    return s__th_le_out(result, b_self, b_other);
}
Tensor & s__th_le_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_le(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_le");
    return s__th_le(b_self, b_other);
}
Tensor s__th_le(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_leTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_le_byte_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_le_byte(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_leValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_le_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_le_byte_out");
    return s__th_le_byte_out(result, b_self, b_other);
}
Tensor & s__th_le_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_le_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_le_byte");
    return s__th_le_byte(b_self, b_other);
}
Tensor s__th_le_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_le_byte", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_leTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_le_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_le_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_leValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_le_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_le_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_le_");
    return s__th_le_(self, b_other);
}
Tensor & s__th_le_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_le_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_le_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_leTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_le_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ge_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ge(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_geValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ge_out");
    return s__th_ge_out(result, b_self, b_other);
}
Tensor & s__th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ge(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ge");
    return s__th_ge(b_self, b_other);
}
Tensor s__th_ge(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_geTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ge_byte_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ge_byte(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_geValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ge_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ge_byte_out");
    return s__th_ge_byte_out(result, b_self, b_other);
}
Tensor & s__th_ge_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ge_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ge_byte");
    return s__th_ge_byte(b_self, b_other);
}
Tensor s__th_ge_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ge_byte", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_geTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ge_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ge_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_geValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ge_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ge_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_ge_");
    return s__th_ge_(self, b_other);
}
Tensor & s__th_ge_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ge_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ge_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_geTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ge_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_eq_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_eq(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_eqValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_eq_out");
    return s__th_eq_out(result, b_self, b_other);
}
Tensor & s__th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_eq(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_eq");
    return s__th_eq(b_self, b_other);
}
Tensor s__th_eq(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_eqTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_eq_byte_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_eq_byte(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_eqValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_eq_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_eq_byte_out");
    return s__th_eq_byte_out(result, b_self, b_other);
}
Tensor & s__th_eq_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_eq_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_eq_byte");
    return s__th_eq_byte(b_self, b_other);
}
Tensor s__th_eq_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_eq_byte", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_eqTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_eq_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_eq_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = other.toBool();
            THSyclBoolTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_eqValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_eq_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_eq_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_eq_");
    return s__th_eq_(self, b_other);
}
Tensor & s__th_eq_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_eq_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_eq_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_eqTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_eq_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ne_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ne(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_neValue(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ne_out");
    return s__th_ne_out(result, b_self, b_other);
}
Tensor & s__th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ne(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ne");
    return s__th_ne(b_self, b_other);
}
Tensor s__th_ne(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Bool), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_neTensor(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ne_byte_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ne_byte(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_neValueByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ne_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ne_byte_out");
    return s__th_ne_byte_out(result, b_self, b_other);
}
Tensor & s__th_ne_byte_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne_byte_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ne_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_ne_byte");
    return s__th_ne_byte(b_self, b_other);
}
Tensor s__th_ne_byte(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Byte), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_ne_byte", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_neTensorByte(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ne_byte not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ne_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_neValueT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ne_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ne_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_ne_");
    return s__th_ne_(self, b_other);
}
Tensor & s__th_ne_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ne_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_ne_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_neTensorT(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_ne_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_min_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_min_out");
    return s__th_min_out(result, b_self, b_other);
}
Tensor & s__th_min_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_min_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_min(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_min");
    return s__th_min(b_self, b_other);
}
Tensor s__th_min(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_min", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cmin(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_min not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_min(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Bool);
            return at::scalar_tensor(convert<bool>(THSyclBoolTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Bool));
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Byte);
            return at::scalar_tensor(convert<uint8_t>(THSyclByteTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Byte));
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Char);
            return at::scalar_tensor(convert<int8_t>(THSyclCharTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Char));
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Double);
            return at::scalar_tensor(convert<double>(THSyclDoubleTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Double));
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Float);
            return at::scalar_tensor(convert<float>(THSyclTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Float));
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Int);
            return at::scalar_tensor(convert<int>(THSyclIntTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Int));
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Long);
            return at::scalar_tensor(convert<int64_t>(THSyclLongTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Long));
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Short);
            return at::scalar_tensor(convert<int16_t>(THSyclShortTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Short));
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Half);
            return at::scalar_tensor(convert<Half>(THSyclHalfTensor_minall(getTHSYCLState(), self_)), options(ScalarType::Half));
            break;
        }
        default:
            AT_ERROR("_th_min not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor &,Tensor &> _th_min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Byte);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        case ScalarType::Char: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Char);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        case ScalarType::Double: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Double);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        case ScalarType::Float: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Float);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        case ScalarType::Int: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Int);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        case ScalarType::Long: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        case ScalarType::Short: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Short);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        case ScalarType::Half: {
            auto min_ = checked_tensor_unwrap(min, "min", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Half);
            auto min_indices_ = checked_tensor_unwrap(min_indices, "min_indices", 0, "_th_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(min, min_indices);
            break;
        }
        default:
            AT_ERROR("_th_min_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor,Tensor> _th_min(const Tensor & self, int64_t dim, bool keepdim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        case ScalarType::Char: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        case ScalarType::Double: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        case ScalarType::Float: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        case ScalarType::Int: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        case ScalarType::Long: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        case ScalarType::Short: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        case ScalarType::Half: {
            auto min_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_));
            auto min_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto min_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(min_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_min", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_min(getTHSYCLState(), min_, min_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            min_->maybe_zero_dim(maybe_scalar);
            min_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(min, min_indices);
            break;
        }
        default:
            AT_ERROR("_th_min not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_max_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_max_out");
    return s__th_max_out(result, b_self, b_other);
}
Tensor & s__th_max_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_max_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_max(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_max");
    return s__th_max(b_self, b_other);
}
Tensor s__th_max(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Bool);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_max", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cmax(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_max not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_max(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Bool);
            return at::scalar_tensor(convert<bool>(THSyclBoolTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Bool));
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Byte);
            return at::scalar_tensor(convert<uint8_t>(THSyclByteTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Byte));
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Char);
            return at::scalar_tensor(convert<int8_t>(THSyclCharTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Char));
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Double);
            return at::scalar_tensor(convert<double>(THSyclDoubleTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Double));
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Float);
            return at::scalar_tensor(convert<float>(THSyclTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Float));
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Int);
            return at::scalar_tensor(convert<int>(THSyclIntTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Int));
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Long);
            return at::scalar_tensor(convert<int64_t>(THSyclLongTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Long));
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Short);
            return at::scalar_tensor(convert<int16_t>(THSyclShortTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Short));
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Half);
            return at::scalar_tensor(convert<Half>(THSyclHalfTensor_maxall(getTHSYCLState(), self_)), options(ScalarType::Half));
            break;
        }
        default:
            AT_ERROR("_th_max not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor &,Tensor &> _th_max_out(Tensor & max, Tensor & max_indices, const Tensor & self, int64_t dim, bool keepdim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Byte);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        case ScalarType::Char: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Char);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        case ScalarType::Double: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Double);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        case ScalarType::Float: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Float);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        case ScalarType::Int: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Int);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        case ScalarType::Long: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        case ScalarType::Short: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Short);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        case ScalarType::Half: {
            auto max_ = checked_tensor_unwrap(max, "max", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Half);
            auto max_indices_ = checked_tensor_unwrap(max_indices, "max_indices", 0, "_th_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(max, max_indices);
            break;
        }
        default:
            AT_ERROR("_th_max_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor,Tensor> _th_max(const Tensor & self, int64_t dim, bool keepdim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        case ScalarType::Char: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        case ScalarType::Double: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        case ScalarType::Float: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        case ScalarType::Int: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        case ScalarType::Long: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        case ScalarType::Short: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        case ScalarType::Half: {
            auto max_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_));
            auto max_indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto max_indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(max_indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_max", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_max(getTHSYCLState(), max_, max_indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0 || (keepdim == false && self_->dim() == 1);
            max_->maybe_zero_dim(maybe_scalar);
            max_indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(max, max_indices);
            break;
        }
        default:
            AT_ERROR("_th_max not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor &,Tensor &> _th_mode_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool keepdim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Byte);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Char: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Char);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Double: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Double);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Float: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Float);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Int: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Int);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Long: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Short: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Short);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Half: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Half);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_mode_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        default:
            AT_ERROR("_th_mode_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor,Tensor> _th_mode(const Tensor & self, int64_t dim, bool keepdim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Char: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Double: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Float: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Int: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Long: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Short: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Half: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mode", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_mode(getTHSYCLState(), values_, indices_, self_, dim, keepdim);
            bool maybe_scalar = self_->dim() == 0|| (keepdim == false && self_->dim() == 1);
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        default:
            AT_ERROR("_th_mode not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor &,Tensor &> _th_sort_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t dim, bool descending) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Byte);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Char: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Char);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Double: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Double);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Float: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Float);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Int: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Int);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Long: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Short: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Short);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Half: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Half);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_sort_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        default:
            AT_ERROR("_th_sort_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor,Tensor> _th_sort(const Tensor & self, int64_t dim, bool descending) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Char: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Double: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Float: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Int: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Long: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Short: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Half: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sort", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_sort(getTHSYCLState(), values_, indices_, self_, dim, descending);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        default:
            AT_ERROR("_th_sort not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor &,Tensor &> _th_topk_out(Tensor & values, Tensor & indices, const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Byte);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Char: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Char);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Double: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Double);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Float: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Float);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Int: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Int);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Long: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Short: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Short);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        case ScalarType::Half: {
            auto values_ = checked_tensor_unwrap(values, "values", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Half);
            auto indices_ = checked_tensor_unwrap(indices, "indices", 0, "_th_topk_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor &, Tensor &>(values, indices);
            break;
        }
        default:
            AT_ERROR("_th_topk_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor,Tensor> _th_topk(const Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Char: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Double: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Float: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Int: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Long: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Short: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        case ScalarType::Half: {
            auto values_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto values = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(values_));
            auto indices_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(scalarTypeToTypeMeta(ScalarType::Long), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto indices = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(indices_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_topk", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_topk(getTHSYCLState(), values_, indices_, self_, k, dim, largest, sorted);
            bool maybe_scalar = self_->dim() == 0;
            values_->maybe_zero_dim(maybe_scalar);
            indices_->maybe_zero_dim(maybe_scalar);
            return std::tuple<Tensor, Tensor>(values, indices);
            break;
        }
        default:
            AT_ERROR("_th_topk not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_abs_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_abs_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_abs_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_abs(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_abs", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_abs(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_abs not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_sigmoid_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sigmoid_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sigmoid_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sigmoid(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sigmoid_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sigmoid_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sigmoid(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sigmoid_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sigmoid_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sigmoid(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sigmoid_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_sigmoid(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sigmoid", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sigmoid(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sigmoid", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sigmoid(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sigmoid", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sigmoid(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sigmoid not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_log_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_log(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_log10_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log10_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log10_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log10(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log10_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log10_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log10(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log10_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log10_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log10(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log10_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_log10(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log10", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log10(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log10", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log10(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log10", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log10(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log10 not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_log1p_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log1p_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log1p_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log1p(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log1p_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log1p_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log1p(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log1p_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log1p_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log1p(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log1p_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_log1p(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log1p", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log1p(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log1p", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log1p(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log1p", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log1p(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log1p not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_log2_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log2_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log2_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log2(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log2_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log2_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log2(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_log2_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log2_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log2(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log2_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_log2(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log2", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_log2(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log2", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_log2(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_log2", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_log2(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_log2 not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_digamma_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_digamma_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_digamma(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_digamma_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_digamma(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_digamma_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_digamma(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_digamma_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_digamma(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_digamma(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_digamma(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_digamma(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_digamma not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_digamma_(Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_digamma(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_digamma(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_digamma_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_digamma(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_digamma_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_exp_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_exp_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_exp_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_exp(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_exp_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_exp_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_exp(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_exp_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_exp_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_exp(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_exp_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_exp(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_exp", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_exp(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_exp", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_exp(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_exp", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_exp(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_exp not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_expm1_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_expm1_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_expm1_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_expm1(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_expm1_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_expm1_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_expm1(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_expm1_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_expm1_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_expm1(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_expm1_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_expm1(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_expm1", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_expm1(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_expm1", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_expm1(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_expm1", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_expm1(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_expm1 not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_cos_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cos_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cos_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cos_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cos_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cos_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cos_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cos_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_cos(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cos", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cos", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cos", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cos not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_acos_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_acos_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_acos_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_acos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_acos_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_acos_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_acos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_acos_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_acos_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_acos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_acos_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_acos(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_acos", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_acos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_acos", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_acos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_acos", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_acos(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_acos not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_cosh_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cosh_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cosh_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cosh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cosh_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cosh_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cosh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cosh_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cosh_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cosh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cosh_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_cosh(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cosh", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cosh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cosh", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cosh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cosh", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cosh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cosh not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_sin_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sin_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sin_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sin_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sin_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sin_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sin_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sin_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_sin(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sin", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sin", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sin", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sin not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_asin_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_asin_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_asin_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_asin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_asin_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_asin_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_asin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_asin_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_asin_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_asin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_asin_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_asin(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_asin", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_asin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_asin", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_asin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_asin", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_asin(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_asin not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_sinh_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sinh_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sinh_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sinh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sinh_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sinh_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sinh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sinh_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sinh_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sinh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sinh_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_sinh(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sinh", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sinh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sinh", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sinh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sinh", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sinh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sinh not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_tan_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_tan_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tan_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_tan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_tan_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tan_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_tan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_tan_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tan_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_tan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_tan_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_tan(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tan", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_tan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tan", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_tan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tan", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_tan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_tan not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_atan_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_atan_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_atan_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_atan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_atan_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_atan_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_atan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_atan_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_atan_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_atan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_atan_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_atan(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_atan", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_atan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_atan", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_atan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_atan", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_atan(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_atan not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_tanh_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_tanh_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tanh_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_tanh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_tanh_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tanh_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_tanh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_tanh_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tanh_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_tanh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_tanh_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_tanh(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tanh", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_tanh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tanh", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_tanh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_tanh", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_tanh(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_tanh not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_erf_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erf_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erf_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_erf(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erf_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erf_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_erf(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erf_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erf_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_erf(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_erf_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_erf(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erf", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_erf(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erf", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_erf(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erf", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_erf(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_erf not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_erfc_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erfc_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfc_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_erfc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erfc_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfc_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_erfc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erfc_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfc_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_erfc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_erfc_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_erfc(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfc", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_erfc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfc", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_erfc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfc", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_erfc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_erfc not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_erfinv_(Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_erfinv(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_erfinv(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_erfinv(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_erfinv_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_erfinv_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erfinv_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_erfinv(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erfinv_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_erfinv(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_erfinv_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_erfinv(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_erfinv_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_erfinv(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_erfinv(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_erfinv(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_erfinv", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_erfinv(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_erfinv not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_sqrt_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sqrt_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sqrt_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sqrt_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sqrt_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sqrt_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sqrt_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sqrt_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_sqrt(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sqrt", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sqrt", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sqrt", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sqrt not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_rsqrt_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rsqrt_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rsqrt_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_rsqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rsqrt_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rsqrt_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_rsqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_rsqrt_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rsqrt_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_rsqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_rsqrt_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_rsqrt(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rsqrt", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_rsqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rsqrt", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_rsqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_rsqrt", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_rsqrt(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_rsqrt not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ceil_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ceil_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ceil_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_ceil(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ceil_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ceil_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_ceil(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ceil_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ceil_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_ceil(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ceil_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ceil(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ceil", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_ceil(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ceil", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_ceil(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ceil", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_ceil(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ceil not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_floor_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_floor_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_floor_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_floor(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_floor_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_floor_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_floor(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_floor_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_floor_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_floor(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_floor_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_floor(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_floor", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_floor(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_floor", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_floor(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_floor", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_floor(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_floor not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_round_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_round_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_round_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_round(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_round_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_round_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_round(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_round_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_round_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_round(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_round_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_round(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_round", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_round(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_round", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_round(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_round", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_round(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_round not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_trunc_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_trunc_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trunc_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_trunc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_trunc_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trunc_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_trunc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_trunc_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trunc_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_trunc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_trunc_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_trunc(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trunc", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_trunc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trunc", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_trunc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trunc", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_trunc(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_trunc not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_frac_(Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_frac(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_frac(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_frac(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_frac_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_frac_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_frac_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_frac(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_frac_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_frac(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_frac_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_frac(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_frac_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_frac(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_frac(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_frac(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_frac", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_frac(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_frac not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_pow_out(Tensor & result, const Tensor & self, Scalar exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Byte);
            auto exponent_ = exponent.toByte();
            THSyclByteTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Char);
            auto exponent_ = exponent.toChar();
            THSyclCharTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Double);
            auto exponent_ = exponent.toDouble();
            THSyclDoubleTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Float);
            auto exponent_ = exponent.toFloat();
            THSyclTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Int);
            auto exponent_ = exponent.toInt();
            THSyclIntTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Long);
            auto exponent_ = exponent.toLong();
            THSyclLongTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Short);
            auto exponent_ = exponent.toShort();
            THSyclShortTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Half);
            auto exponent_ = exponent.toHalf();
            THSyclHalfTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_pow_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_pow(const Tensor & self, Scalar exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Byte);
            auto exponent_ = exponent.toByte();
            THSyclByteTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Char);
            auto exponent_ = exponent.toChar();
            THSyclCharTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Double);
            auto exponent_ = exponent.toDouble();
            THSyclDoubleTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Float);
            auto exponent_ = exponent.toFloat();
            THSyclTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Int);
            auto exponent_ = exponent.toInt();
            THSyclIntTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Long);
            auto exponent_ = exponent.toLong();
            THSyclLongTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Short);
            auto exponent_ = exponent.toShort();
            THSyclShortTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Half);
            auto exponent_ = exponent.toHalf();
            THSyclHalfTensor_pow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_pow not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_pow_out(Tensor & result, const Tensor & self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_exponent;
    std::tie(b_self, b_exponent) = expand_outplace(self, exponent, "_th_pow_out");
    return s__th_pow_out(result, b_self, b_exponent);
}
Tensor & s__th_pow_out(Tensor & result, const Tensor & self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Byte);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Char);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Double);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Float);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Int);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Long);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Short);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_out", false, Backend::DPCPP, ScalarType::Half);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_pow_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_pow(const Tensor & self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_exponent;
    std::tie(b_self, b_exponent) = expand_outplace(self, exponent, "_th_pow");
    return s__th_pow(b_self, b_exponent);
}
Tensor s__th_pow(const Tensor & self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Byte);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Char);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Double);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Float);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Int);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Long);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Short);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow", false, Backend::DPCPP, ScalarType::Half);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(self_->dim() == 0 && exponent_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_pow not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_pow_out(Tensor & result, Scalar self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(result);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = self.toByte();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = self.toChar();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = self.toDouble();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = self.toFloat();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = self.toInt();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = self.toLong();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = self.toShort();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_pow_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = self.toHalf();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_pow_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_pow(Scalar self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(exponent);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toByte();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toChar();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toDouble();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toFloat();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toInt();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toLong();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toShort();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = self.toHalf();
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 2, "_th_pow", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_tpow(getTHSYCLState(), result_, self_, exponent_);
            result_->maybe_zero_dim(exponent_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_pow not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_pow_(Tensor & self, Scalar exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Byte);
            auto exponent_ = exponent.toByte();
            THSyclByteTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Char);
            auto exponent_ = exponent.toChar();
            THSyclCharTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Double);
            auto exponent_ = exponent.toDouble();
            THSyclDoubleTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Float);
            auto exponent_ = exponent.toFloat();
            THSyclTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Int);
            auto exponent_ = exponent.toInt();
            THSyclIntTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Long);
            auto exponent_ = exponent.toLong();
            THSyclLongTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Short);
            auto exponent_ = exponent.toShort();
            THSyclShortTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Half);
            auto exponent_ = exponent.toHalf();
            THSyclHalfTensor_pow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_pow_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_pow_(Tensor & self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_exponent;
    std::tie(b_exponent) = expand_inplace(self, exponent, "_th_pow_");
    return s__th_pow_(self, b_exponent);
}
Tensor & s__th_pow_(Tensor & self, const Tensor & exponent) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Byte);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Char);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Double);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Float);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Int);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Long);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Short);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_pow_", false, Backend::DPCPP, ScalarType::Half);
            auto exponent_ = checked_tensor_unwrap(exponent, "exponent", 3, "_th_pow_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cpow(getTHSYCLState(), self_, self_, exponent_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_pow_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_zero_(Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_zero_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_zero(getTHSYCLState(), self_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_zero_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_cumsum_out(Tensor & result, const Tensor & self, int64_t dim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cumsum_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_cumsum(const Tensor & self, int64_t dim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumsum", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_cumsum(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cumsum not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_cumprod_out(Tensor & result, const Tensor & self, int64_t dim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod_out", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cumprod_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_cumprod(const Tensor & self, int64_t dim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Byte);
            dim = maybe_wrap_dim(dim, self_);
            THSyclByteTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Char);
            dim = maybe_wrap_dim(dim, self_);
            THSyclCharTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Double);
            dim = maybe_wrap_dim(dim, self_);
            THSyclDoubleTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Float);
            dim = maybe_wrap_dim(dim, self_);
            THSyclTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Int);
            dim = maybe_wrap_dim(dim, self_);
            THSyclIntTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Long);
            dim = maybe_wrap_dim(dim, self_);
            THSyclLongTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Short);
            dim = maybe_wrap_dim(dim, self_);
            THSyclShortTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_cumprod", false, Backend::DPCPP, ScalarType::Half);
            dim = maybe_wrap_dim(dim, self_);
            THSyclHalfTensor_cumprod(getTHSYCLState(), result_, self_, dim);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_cumprod not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_sign_out(Tensor & result, const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Bool);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_sign_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sign_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_sign(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sign(getTHSYCLState(), result_, self_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_sign not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_sign_(Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_sign_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_sign(getTHSYCLState(), self_, self_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_sign_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_trace(const Tensor & self) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Byte);
            return at::scalar_tensor(convert<uint8_t>(THSyclByteTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Byte));
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Char);
            return at::scalar_tensor(convert<int8_t>(THSyclCharTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Char));
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Double);
            return at::scalar_tensor(convert<double>(THSyclDoubleTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Double));
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Float);
            return at::scalar_tensor(convert<float>(THSyclTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Float));
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Int);
            return at::scalar_tensor(convert<int>(THSyclIntTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Int));
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Long);
            return at::scalar_tensor(convert<int64_t>(THSyclLongTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Long));
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Short);
            return at::scalar_tensor(convert<int16_t>(THSyclShortTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Short));
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_trace", false, Backend::DPCPP, ScalarType::Half);
            return at::scalar_tensor(convert<Half>(THSyclHalfTensor_trace(getTHSYCLState(), self_)), options(ScalarType::Half));
            break;
        }
        default:
            AT_ERROR("_th_trace not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_fmod_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_fmod_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_fmod(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_fmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_fmod not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_fmod_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_fmod_out");
    return s__th_fmod_out(result, b_self, b_other);
}
Tensor & s__th_fmod_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_fmod_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_fmod(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_fmod");
    return s__th_fmod(b_self, b_other);
}
Tensor s__th_fmod(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_fmod", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cfmod(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_fmod not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_fmod_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_fmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_fmod_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_fmod_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_fmod_");
    return s__th_fmod_(self, b_other);
}
Tensor & s__th_fmod_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_fmod_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_fmod_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cfmod(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_fmod_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_remainder_out(Tensor & result, const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_remainder_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_remainder(const Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_remainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_remainder not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_remainder_out");
    return s__th_remainder_out(result, b_self, b_other);
}
Tensor & s__th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_remainder_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_remainder(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self, b_other;
    std::tie(b_self, b_other) = expand_outplace(self, other, "_th_remainder");
    return s__th_remainder(b_self, b_other);
}
Tensor s__th_remainder(const Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 2, "_th_remainder", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cremainder(getTHSYCLState(), result_, self_, other_);
            result_->maybe_zero_dim(self_->dim() == 0 && other_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_remainder not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_remainder_(Tensor & self, Scalar other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = other.toByte();
            THSyclByteTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = other.toChar();
            THSyclCharTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = other.toDouble();
            THSyclDoubleTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = other.toFloat();
            THSyclTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = other.toInt();
            THSyclIntTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = other.toLong();
            THSyclLongTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = other.toShort();
            THSyclShortTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = other.toHalf();
            THSyclHalfTensor_remainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_remainder_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_remainder_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_other;
    std::tie(b_other) = expand_inplace(self, other, "_th_remainder_");
    return s__th_remainder_(self, b_other);
}
Tensor & s__th_remainder_(Tensor & self, const Tensor & other) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Byte);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Char);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Double);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Float);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Int);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Long);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Short);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_remainder_", false, Backend::DPCPP, ScalarType::Half);
            auto other_ = checked_tensor_unwrap(other, "other", 3, "_th_remainder_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_cremainder(getTHSYCLState(), self_, self_, other_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_remainder_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_clamp_out(Tensor & result, const Tensor & self, Scalar min, Scalar max) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Byte);
            auto min_ = min.toByte();
            auto max_ = max.toByte();
            THSyclByteTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Char);
            auto min_ = min.toChar();
            auto max_ = max.toChar();
            THSyclCharTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Double);
            auto min_ = min.toDouble();
            auto max_ = max.toDouble();
            THSyclDoubleTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Float);
            auto min_ = min.toFloat();
            auto max_ = max.toFloat();
            THSyclTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Int);
            auto min_ = min.toInt();
            auto max_ = max.toInt();
            THSyclIntTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Long);
            auto min_ = min.toLong();
            auto max_ = max.toLong();
            THSyclLongTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Short);
            auto min_ = min.toShort();
            auto max_ = max.toShort();
            THSyclShortTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_out", false, Backend::DPCPP, ScalarType::Half);
            auto min_ = min.toHalf();
            auto max_ = max.toHalf();
            THSyclHalfTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_clamp_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_clamp(const Tensor & self, Scalar min, Scalar max) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Byte);
            auto min_ = min.toByte();
            auto max_ = max.toByte();
            THSyclByteTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Char);
            auto min_ = min.toChar();
            auto max_ = max.toChar();
            THSyclCharTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Double);
            auto min_ = min.toDouble();
            auto max_ = max.toDouble();
            THSyclDoubleTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Float);
            auto min_ = min.toFloat();
            auto max_ = max.toFloat();
            THSyclTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Int);
            auto min_ = min.toInt();
            auto max_ = max.toInt();
            THSyclIntTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Long);
            auto min_ = min.toLong();
            auto max_ = max.toLong();
            THSyclLongTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Short);
            auto min_ = min.toShort();
            auto max_ = max.toShort();
            THSyclShortTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp", false, Backend::DPCPP, ScalarType::Half);
            auto min_ = min.toHalf();
            auto max_ = max.toHalf();
            THSyclHalfTensor_clamp(getTHSYCLState(), result_, self_, min_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_clamp not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_clamp_min_out(Tensor & result, const Tensor & self, Scalar min) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Byte);
            auto min_ = min.toByte();
            THSyclByteTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Char);
            auto min_ = min.toChar();
            THSyclCharTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Double);
            auto min_ = min.toDouble();
            THSyclDoubleTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Float);
            auto min_ = min.toFloat();
            THSyclTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Int);
            auto min_ = min.toInt();
            THSyclIntTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Long);
            auto min_ = min.toLong();
            THSyclLongTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Short);
            auto min_ = min.toShort();
            THSyclShortTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min_out", false, Backend::DPCPP, ScalarType::Half);
            auto min_ = min.toHalf();
            THSyclHalfTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_clamp_min_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_clamp_min(const Tensor & self, Scalar min) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Byte);
            auto min_ = min.toByte();
            THSyclByteTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Char);
            auto min_ = min.toChar();
            THSyclCharTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Double);
            auto min_ = min.toDouble();
            THSyclDoubleTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Float);
            auto min_ = min.toFloat();
            THSyclTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Int);
            auto min_ = min.toInt();
            THSyclIntTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Long);
            auto min_ = min.toLong();
            THSyclLongTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Short);
            auto min_ = min.toShort();
            THSyclShortTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_min", false, Backend::DPCPP, ScalarType::Half);
            auto min_ = min.toHalf();
            THSyclHalfTensor_cmaxValue(getTHSYCLState(), result_, self_, min_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_clamp_min not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_clamp_max_out(Tensor & result, const Tensor & self, Scalar max) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Byte);
            auto max_ = max.toByte();
            THSyclByteTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Char);
            auto max_ = max.toChar();
            THSyclCharTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Double);
            auto max_ = max.toDouble();
            THSyclDoubleTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Float);
            auto max_ = max.toFloat();
            THSyclTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Int);
            auto max_ = max.toInt();
            THSyclIntTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Long);
            auto max_ = max.toLong();
            THSyclLongTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Short);
            auto max_ = max.toShort();
            THSyclShortTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max_out", false, Backend::DPCPP, ScalarType::Half);
            auto max_ = max.toHalf();
            THSyclHalfTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_clamp_max_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_clamp_max(const Tensor & self, Scalar max) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Byte);
            auto max_ = max.toByte();
            THSyclByteTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Char);
            auto max_ = max.toChar();
            THSyclCharTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Double);
            auto max_ = max.toDouble();
            THSyclDoubleTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Float);
            auto max_ = max.toFloat();
            THSyclTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Int);
            auto max_ = max.toInt();
            THSyclIntTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Long);
            auto max_ = max.toLong();
            THSyclLongTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Short);
            auto max_ = max.toShort();
            THSyclShortTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_clamp_max", false, Backend::DPCPP, ScalarType::Half);
            auto max_ = max.toHalf();
            THSyclHalfTensor_cminValue(getTHSYCLState(), result_, self_, max_);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_clamp_max not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_diag_out(Tensor & result, const Tensor & self, int64_t diagonal) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Byte);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Byte);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclByteTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Char);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Char);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclCharTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Double);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclDoubleTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Float);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Int);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Int);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclIntTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Long);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Long);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclLongTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Short);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Short);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclShortTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_diag_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag_out", false, Backend::DPCPP, ScalarType::Half);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclHalfTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_diag_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_diag(const Tensor & self, int64_t diagonal) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Byte);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclByteTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Char);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclCharTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Double);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclDoubleTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Float);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Int);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclIntTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Long);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclLongTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Short);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclShortTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_diag", false, Backend::DPCPP, ScalarType::Half);
            if (self_->dim() == 0) {
              throw std::runtime_error("Input must be 1-d or 2-d");
            }
            THSyclHalfTensor_diag(getTHSYCLState(), result_, self_, diagonal);
            result_->maybe_zero_dim(self_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_diag not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat1.size(0),mat2.size(1)}, "_th_addmm_out");
    return s__th_addmm_out(result, b_self, mat1, mat2, beta, alpha);
}
Tensor & s__th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addmm_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat1.size(0),mat2.size(1)}, "_th_addmm");
    return s__th_addmm(b_self, mat1, mat2, beta, alpha);
}
Tensor s__th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Byte);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Char);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Double);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Float);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Int);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Long);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Short);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmm", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 4, "_th_addmm", false, Backend::DPCPP, ScalarType::Half);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 5, "_th_addmm", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmm(getTHSYCLState(), result_, beta_, self_, alpha_, mat1_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addmm not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addmm_(Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto alpha_ = alpha.toByte();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Byte);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto alpha_ = alpha.toChar();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Char);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto alpha_ = alpha.toDouble();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Double);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto alpha_ = alpha.toFloat();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Float);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto alpha_ = alpha.toInt();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Int);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto alpha_ = alpha.toLong();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Long);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto alpha_ = alpha.toShort();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Short);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmm_", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto alpha_ = alpha.toHalf();
            auto mat1_ = checked_tensor_unwrap(mat1, "mat1", 5, "_th_addmm_", false, Backend::DPCPP, ScalarType::Half);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 6, "_th_addmm_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmm(getTHSYCLState(), self_, beta_, self_, alpha_, mat1_, mat2_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_addmm_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addmv_out(Tensor & result, const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat.size(0)}, "_th_addmv_out");
    return s__th_addmv_out(result, b_self, mat, vec, beta, alpha);
}
Tensor & s__th_addmv_out(Tensor & result, const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Byte);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Char);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Double);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Float);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Int);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Long);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Short);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Half);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addmv_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_addmv(const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {mat.size(0)}, "_th_addmv");
    return s__th_addmv(b_self, mat, vec, beta, alpha);
}
Tensor s__th_addmv(const Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Byte);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Char);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Double);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Float);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Int);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Long);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Short);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addmv", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 4, "_th_addmv", false, Backend::DPCPP, ScalarType::Half);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 5, "_th_addmv", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmv(getTHSYCLState(), result_, beta_, self_, alpha_, mat_, vec_);
            result_->maybe_zero_dim(self_->dim() == 0 && mat_->dim() == 0 && vec_->dim() == 0);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addmv not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addmv_(Tensor & self, const Tensor & mat, const Tensor & vec, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto alpha_ = alpha.toByte();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Byte);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto alpha_ = alpha.toChar();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Char);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto alpha_ = alpha.toDouble();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Double);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto alpha_ = alpha.toFloat();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Float);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto alpha_ = alpha.toInt();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Int);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto alpha_ = alpha.toLong();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Long);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto alpha_ = alpha.toShort();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Short);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addmv_", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto alpha_ = alpha.toHalf();
            auto mat_ = checked_tensor_unwrap(mat, "mat", 5, "_th_addmv_", false, Backend::DPCPP, ScalarType::Half);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 6, "_th_addmv_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmv(getTHSYCLState(), self_, beta_, self_, alpha_, mat_, vec_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_addmv_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addr_out(Tensor & result, const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {vec1.size(0),vec2.size(0)}, "_th_addr_out");
    return s__th_addr_out(result, b_self, vec1, vec2, beta, alpha);
}
Tensor & s__th_addr_out(Tensor & result, const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Byte);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Char);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Double);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Float);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Int);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Long);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Short);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addr_out", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr_out", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr_out", false, Backend::DPCPP, ScalarType::Half);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addr_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_addr(const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {vec1.size(0),vec2.size(0)}, "_th_addr");
    return s__th_addr(b_self, vec1, vec2, beta, alpha);
}
Tensor s__th_addr(const Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Byte);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Char);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Double);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Float);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Int);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Long);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Short);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addr", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 4, "_th_addr", false, Backend::DPCPP, ScalarType::Half);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 5, "_th_addr", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addr(getTHSYCLState(), result_, beta_, self_, alpha_, vec1_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addr not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addr_(Tensor & self, const Tensor & vec1, const Tensor & vec2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto alpha_ = alpha.toByte();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Byte);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto alpha_ = alpha.toChar();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Char);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto alpha_ = alpha.toDouble();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Double);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto alpha_ = alpha.toFloat();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Float);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto alpha_ = alpha.toInt();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Int);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto alpha_ = alpha.toLong();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Long);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto alpha_ = alpha.toShort();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Short);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addr_", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto alpha_ = alpha.toHalf();
            auto vec1_ = checked_tensor_unwrap(vec1, "vec1", 5, "_th_addr_", false, Backend::DPCPP, ScalarType::Half);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 6, "_th_addr_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addr(getTHSYCLState(), self_, beta_, self_, alpha_, vec1_, vec2_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_addr_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_ger_out(Tensor & result, const Tensor & self, const Tensor & vec2) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Byte);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Byte);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addr(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Char);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Char);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addr(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Double);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Double);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addr(getTHSYCLState(), result_, double(0), result_, double(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Float);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Float);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addr(getTHSYCLState(), result_, float(0), result_, float(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Int);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Int);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addr(getTHSYCLState(), result_, int(0), result_, int(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Long);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Long);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addr(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Short);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Short);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addr(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_ger_out", false, Backend::DPCPP, ScalarType::Half);
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger_out", false, Backend::DPCPP, ScalarType::Half);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addr(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ger_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_ger(const Tensor & self, const Tensor & vec2) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Byte);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addr(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Char);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addr(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Double);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addr(getTHSYCLState(), result_, double(0), result_, double(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Float);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addr(getTHSYCLState(), result_, float(0), result_, float(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Int);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addr(getTHSYCLState(), result_, int(0), result_, int(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Long);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addr(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Short);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addr(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.dim() == 0 ? 1 : self.size(0),vec2.dim() == 0 ? 1 : vec2.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_ger", false, Backend::DPCPP, ScalarType::Half);
            auto vec2_ = checked_tensor_unwrap(vec2, "vec2", 2, "_th_ger", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addr(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, vec2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_ger not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_mv_out(Tensor & result, const Tensor & self, const Tensor & vec) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Byte);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Byte);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmv(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Char);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Char);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmv(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Double);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Double);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmv(getTHSYCLState(), result_, double(0), result_, double(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Float);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Float);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmv(getTHSYCLState(), result_, float(0), result_, float(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Int);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Int);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmv(getTHSYCLState(), result_, int(0), result_, int(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Long);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Long);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmv(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Short);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Short);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmv(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mv_out", false, Backend::DPCPP, ScalarType::Half);
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv_out", false, Backend::DPCPP, ScalarType::Half);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmv(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_mv_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_mv(const Tensor & self, const Tensor & vec) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Byte);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmv(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Char);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmv(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Double);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmv(getTHSYCLState(), result_, double(0), result_, double(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Float);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmv(getTHSYCLState(), result_, float(0), result_, float(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Int);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmv(getTHSYCLState(), result_, int(0), result_, int(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Long);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmv(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Short);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmv(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mv", false, Backend::DPCPP, ScalarType::Half);
            auto vec_ = checked_tensor_unwrap(vec, "vec", 2, "_th_mv", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmv(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, vec_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_mv not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_mm_out(Tensor & result, const Tensor & self, const Tensor & mat2) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Byte);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmm(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Char);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Char);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmm(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Double);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Double);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmm(getTHSYCLState(), result_, double(0), result_, double(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Float);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Float);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmm(getTHSYCLState(), result_, float(0), result_, float(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Int);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Int);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmm(getTHSYCLState(), result_, int(0), result_, int(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Long);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Long);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmm(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Short);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Short);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmm(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_mm_out", false, Backend::DPCPP, ScalarType::Half);
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm_out", false, Backend::DPCPP, ScalarType::Half);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmm(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_mm_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_mm(const Tensor & self, const Tensor & mat2) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Byte);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addmm(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Char);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addmm(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Double);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addmm(getTHSYCLState(), result_, double(0), result_, double(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Float);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addmm(getTHSYCLState(), result_, float(0), result_, float(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Int);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addmm(getTHSYCLState(), result_, int(0), result_, int(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Long);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addmm(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Short);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addmm(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),mat2.size(1) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_mm", false, Backend::DPCPP, ScalarType::Half);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_mm", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addmm(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_mm not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_bmm_out(Tensor & result, const Tensor & self, const Tensor & mat2) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Byte);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_baddbmm(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Char);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_baddbmm(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Double);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_baddbmm(getTHSYCLState(), result_, double(0), result_, double(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Float);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_baddbmm(getTHSYCLState(), result_, float(0), result_, float(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Int);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_baddbmm(getTHSYCLState(), result_, int(0), result_, int(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Long);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_baddbmm(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Short);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_baddbmm(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Half);
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_baddbmm(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_bmm_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_bmm(const Tensor & self, const Tensor & mat2) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Byte);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_baddbmm(getTHSYCLState(), result_, uint8_t(0), result_, uint8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Char);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_baddbmm(getTHSYCLState(), result_, int8_t(0), result_, int8_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Double);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_baddbmm(getTHSYCLState(), result_, double(0), result_, double(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Float);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_baddbmm(getTHSYCLState(), result_, float(0), result_, float(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Int);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_baddbmm(getTHSYCLState(), result_, int(0), result_, int(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Long);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_baddbmm(getTHSYCLState(), result_, int64_t(0), result_, int64_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Short);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_baddbmm(getTHSYCLState(), result_, int16_t(0), result_, int16_t(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            result.resize_({ self.size(0),self.size(1),mat2.size(2) });
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_bmm", false, Backend::DPCPP, ScalarType::Half);
            auto mat2_ = checked_tensor_unwrap(mat2, "mat2", 2, "_th_bmm", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_baddbmm(getTHSYCLState(), result_, Half(0), result_, Half(1), self_, mat2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_bmm not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(1),batch2.size(2)}, "_th_addbmm_out");
    return s__th_addbmm_out(result, b_self, batch1, batch2, beta, alpha);
}
Tensor & s__th_addbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addbmm_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_addbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(1),batch2.size(2)}, "_th_addbmm");
    return s__th_addbmm(b_self, batch1, batch2, beta, alpha);
}
Tensor s__th_addbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Byte);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Char);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Double);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Float);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Int);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Long);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Short);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_addbmm", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_addbmm", false, Backend::DPCPP, ScalarType::Half);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_addbmm", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_addbmm not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_addbmm_(Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto alpha_ = alpha.toByte();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Byte);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto alpha_ = alpha.toChar();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Char);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto alpha_ = alpha.toDouble();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Double);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto alpha_ = alpha.toFloat();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Float);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto alpha_ = alpha.toInt();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Int);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto alpha_ = alpha.toLong();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Long);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto alpha_ = alpha.toShort();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Short);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto alpha_ = alpha.toHalf();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 5, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Half);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 6, "_th_addbmm_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_addbmm(getTHSYCLState(), self_, beta_, self_, alpha_, batch1_, batch2_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_addbmm_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_baddbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(0),batch1.size(1),batch2.size(2)}, "_th_baddbmm_out");
    return s__th_baddbmm_out(result, b_self, batch1, batch2, beta, alpha);
}
Tensor & s__th_baddbmm_out(Tensor & result, const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Char);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Double);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Float);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Int);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Long);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Short);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = checked_tensor_unwrap(result, "result", 0, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Half);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm_out", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_baddbmm_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_baddbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    Tensor b_self;
    std::tie(b_self) = expand_size(self, {batch1.size(0),batch1.size(1),batch2.size(2)}, "_th_baddbmm");
    return s__th_baddbmm(b_self, batch1, batch2, beta, alpha);
}
Tensor s__th_baddbmm(const Tensor & self, const Tensor & batch1, const Tensor & batch2, Scalar beta, Scalar alpha) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toByte();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Byte);
            auto alpha_ = alpha.toByte();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Byte);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Char: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toChar();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Char);
            auto alpha_ = alpha.toChar();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Char);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Double: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toDouble();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Double);
            auto alpha_ = alpha.toDouble();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Double);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Float: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toFloat();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Float);
            auto alpha_ = alpha.toFloat();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Float);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Int: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toInt();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Int);
            auto alpha_ = alpha.toInt();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Int);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Long: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toLong();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Long);
            auto alpha_ = alpha.toLong();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Long);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Short: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toShort();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Short);
            auto alpha_ = alpha.toShort();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Short);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        case ScalarType::Half: {
            auto result_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto result = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(result_));
            auto beta_ = beta.toHalf();
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Half);
            auto alpha_ = alpha.toHalf();
            auto batch1_ = checked_tensor_unwrap(batch1, "batch1", 4, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Half);
            auto batch2_ = checked_tensor_unwrap(batch2, "batch2", 5, "_th_baddbmm", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_baddbmm(getTHSYCLState(), result_, beta_, self_, alpha_, batch1_, batch2_);
            result_->maybe_zero_dim(false);
            return result;
            break;
        }
        default:
            AT_ERROR("_th_baddbmm not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_normal_(Tensor & self, double mean, double std, Generator * generator) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_normal_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_normal(getTHSYCLState(), self_, generator, mean, std);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_normal_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_normal(getTHSYCLState(), self_, generator, mean, std);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_normal_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_normal(getTHSYCLState(), self_, generator, mean, std);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_normal_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_copy_ignoring_overlaps_(Tensor & self, const Tensor & src) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Byte);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Char);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Double);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Float);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Int);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Long);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Short);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Half);
            auto src_ = checked_tensor_unwrap(src, "src", 2, "_th_copy_ignoring_overlaps_", false, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_copyIgnoringOverlaps(getTHSYCLState(), self_, src_);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_copy_ignoring_overlaps_ not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _th_cat_out(Tensor & self, TensorList tensors, int64_t dim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Bool);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Byte);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Char);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Double);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Float);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Int);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Long);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Short);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 0, "_th_cat_out", false, Backend::DPCPP, ScalarType::Half);
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_cat_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _th_cat(TensorList tensors, int64_t dim) {
#ifdef BUILD_NAMEDTENSOR

#endif
    // DeviceGuard omitted
    auto dispatch_scalar_type = infer_scalar_type(tensors);
    switch (dispatch_scalar_type) {
        case ScalarType::Bool: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<bool>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Bool);
            THSyclBoolTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Byte: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<uint8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Byte);
            THSyclByteTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Char: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int8_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Char);
            THSyclCharTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Double: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Double);
            THSyclDoubleTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Float: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Float);
            THSyclTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Int: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Int);
            THSyclIntTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Long: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int64_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Long);
            THSyclLongTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Short: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<int16_t>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Short);
            THSyclShortTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        case ScalarType::Half: {
            auto self_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto self = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(self_));
            auto tensors_ = checked_tensor_list_unwrap(tensors,"tensors",1, Backend::DPCPP, ScalarType::Half);
            THSyclHalfTensor_catArray(getTHSYCLState(), self_, tensors_.data(), tensors_.size(), dim);
            return self;
            break;
        }
        default:
            AT_ERROR("_th_cat not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _thnn_binary_cross_entropy_forward_out(Tensor & output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (output.has_names() || self.has_names() || target.has_names() || weight.has_names()) {
        AT_ERROR("_thnn_binary_cross_entropy_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_binary_cross_entropy_forward_out", true, Backend::DPCPP, ScalarType::Double);
            auto output_ = checked_tensor_unwrap(output, "output", 4, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleBCECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_binary_cross_entropy_forward_out", true, Backend::DPCPP, ScalarType::Float);
            auto output_ = checked_tensor_unwrap(output, "output", 4, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclBCECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_binary_cross_entropy_forward_out", true, Backend::DPCPP, ScalarType::Half);
            auto output_ = checked_tensor_unwrap(output, "output", 4, "_thnn_binary_cross_entropy_forward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfBCECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        default:
            AT_ERROR("_thnn_binary_cross_entropy_forward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _thnn_binary_cross_entropy_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (self.has_names() || target.has_names() || weight.has_names()) {
        AT_ERROR("_thnn_binary_cross_entropy_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_binary_cross_entropy_forward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_binary_cross_entropy_forward", false, Backend::DPCPP, ScalarType::Double);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_binary_cross_entropy_forward", true, Backend::DPCPP, ScalarType::Double);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclDoubleBCECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_binary_cross_entropy_forward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_binary_cross_entropy_forward", false, Backend::DPCPP, ScalarType::Float);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_binary_cross_entropy_forward", true, Backend::DPCPP, ScalarType::Float);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclBCECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_binary_cross_entropy_forward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_binary_cross_entropy_forward", false, Backend::DPCPP, ScalarType::Half);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_binary_cross_entropy_forward", true, Backend::DPCPP, ScalarType::Half);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclHalfBCECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        default:
            AT_ERROR("_thnn_binary_cross_entropy_forward not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _thnn_binary_cross_entropy_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_input.has_names() || grad_output.has_names() || self.has_names() || target.has_names() || weight.has_names()) {
        AT_ERROR("_thnn_binary_cross_entropy_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_binary_cross_entropy_backward_out", true, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 5, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleBCECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_binary_cross_entropy_backward_out", true, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 5, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclBCECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_binary_cross_entropy_backward_out", true, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 5, "_thnn_binary_cross_entropy_backward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfBCECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_binary_cross_entropy_backward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _thnn_binary_cross_entropy_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_output.has_names() || self.has_names() || target.has_names() || weight.has_names()) {
        AT_ERROR("_thnn_binary_cross_entropy_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Double);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_binary_cross_entropy_backward", true, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclDoubleBCECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Float);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_binary_cross_entropy_backward", true, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclBCECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_binary_cross_entropy_backward", false, Backend::DPCPP, ScalarType::Half);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_binary_cross_entropy_backward", true, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclHalfBCECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_binary_cross_entropy_backward not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _thnn_l1_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (output.has_names() || self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_l1_loss_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto output_ = checked_tensor_unwrap(output, "output", 3, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleAbsCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto output_ = checked_tensor_unwrap(output, "output", 3, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclAbsCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto output_ = checked_tensor_unwrap(output, "output", 3, "_thnn_l1_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfAbsCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        default:
            AT_ERROR("_thnn_l1_loss_forward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _thnn_l1_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_l1_loss_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_l1_loss_forward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_l1_loss_forward", false, Backend::DPCPP, ScalarType::Double);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclDoubleAbsCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_l1_loss_forward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_l1_loss_forward", false, Backend::DPCPP, ScalarType::Float);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclAbsCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_l1_loss_forward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_l1_loss_forward", false, Backend::DPCPP, ScalarType::Half);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclHalfAbsCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        default:
            AT_ERROR("_thnn_l1_loss_forward not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _thnn_l1_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_input.has_names() || grad_output.has_names() || self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_l1_loss_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 4, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleAbsCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 4, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclAbsCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 4, "_thnn_l1_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfAbsCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_l1_loss_backward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _thnn_l1_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_output.has_names() || self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_l1_loss_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclDoubleAbsCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclAbsCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_l1_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclHalfAbsCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_l1_loss_backward not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _thnn_mse_loss_forward_out(Tensor & output, const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (output.has_names() || self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_mse_loss_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto output_ = checked_tensor_unwrap(output, "output", 3, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleMSECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto output_ = checked_tensor_unwrap(output, "output", 3, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclMSECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto output_ = checked_tensor_unwrap(output, "output", 3, "_thnn_mse_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfMSECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        default:
            AT_ERROR("_thnn_mse_loss_forward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _thnn_mse_loss_forward(const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_mse_loss_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_mse_loss_forward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_mse_loss_forward", false, Backend::DPCPP, ScalarType::Double);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclDoubleMSECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_mse_loss_forward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_mse_loss_forward", false, Backend::DPCPP, ScalarType::Float);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclMSECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_mse_loss_forward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_mse_loss_forward", false, Backend::DPCPP, ScalarType::Half);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            THNN_SyclHalfMSECriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction);
            output_->maybe_zero_dim(false);
            return output;
            break;
        }
        default:
            AT_ERROR("_thnn_mse_loss_forward not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _thnn_mse_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_input.has_names() || grad_output.has_names() || self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_mse_loss_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 4, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleMSECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 4, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclMSECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 4, "_thnn_mse_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfMSECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_mse_loss_backward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _thnn_mse_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, int64_t reduction) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_output.has_names() || self.has_names() || target.has_names()) {
        AT_ERROR("_thnn_mse_loss_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclDoubleMSECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclMSECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_mse_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclHalfMSECriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction);
            grad_input_->maybe_zero_dim(false);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_mse_loss_backward not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor &,Tensor &> _thnn_nll_loss_forward_out(Tensor & output, Tensor & total_weight, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) {
#ifdef BUILD_NAMEDTENSOR
    if (output.has_names() || total_weight.has_names() || self.has_names() || target.has_names() || weight.has_names()) {
        AT_ERROR("_thnn_nll_loss_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_nll_loss_forward_out", true, Backend::DPCPP, ScalarType::Double);
            auto output_ = checked_tensor_unwrap(output, "output", 5, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 5, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleClassNLLCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
            total_weight_->maybe_zero_dim(true);
            return std::tuple<Tensor &, Tensor &>(output, total_weight);
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_nll_loss_forward_out", true, Backend::DPCPP, ScalarType::Float);
            auto output_ = checked_tensor_unwrap(output, "output", 5, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 5, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclClassNLLCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
            total_weight_->maybe_zero_dim(true);
            return std::tuple<Tensor &, Tensor &>(output, total_weight);
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_nll_loss_forward_out", true, Backend::DPCPP, ScalarType::Half);
            auto output_ = checked_tensor_unwrap(output, "output", 5, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 5, "_thnn_nll_loss_forward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfClassNLLCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
            total_weight_->maybe_zero_dim(true);
            return std::tuple<Tensor &, Tensor &>(output, total_weight);
            break;
        }
        default:
            AT_ERROR("_thnn_nll_loss_forward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
std::tuple<Tensor,Tensor> _thnn_nll_loss_forward(const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index) {
#ifdef BUILD_NAMEDTENSOR
    if (self.has_names() || target.has_names() || weight.has_names()) {
        AT_ERROR("_thnn_nll_loss_forward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_nll_loss_forward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_nll_loss_forward", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_nll_loss_forward", true, Backend::DPCPP, ScalarType::Double);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            auto total_weight_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto total_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(total_weight_));
            THNN_SyclDoubleClassNLLCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
            total_weight_->maybe_zero_dim(true);
            return std::tuple<Tensor, Tensor>(output, total_weight);
            break;
        }
        case ScalarType::Float: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_nll_loss_forward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_nll_loss_forward", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_nll_loss_forward", true, Backend::DPCPP, ScalarType::Float);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            auto total_weight_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto total_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(total_weight_));
            THNN_SyclClassNLLCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
            total_weight_->maybe_zero_dim(true);
            return std::tuple<Tensor, Tensor>(output, total_weight);
            break;
        }
        case ScalarType::Half: {
            auto self_ = checked_tensor_unwrap(self, "self", 1, "_thnn_nll_loss_forward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 2, "_thnn_nll_loss_forward", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 3, "_thnn_nll_loss_forward", true, Backend::DPCPP, ScalarType::Half);
            auto output_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto output = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(output_));
            auto total_weight_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto total_weight = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(total_weight_));
            THNN_SyclHalfClassNLLCriterion_updateOutput(getTHSYCLState(), self_, target_, output_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            output_->maybe_zero_dim(reduction != Reduction::None || self_->dim() == 0);
            total_weight_->maybe_zero_dim(true);
            return std::tuple<Tensor, Tensor>(output, total_weight);
            break;
        }
        default:
            AT_ERROR("_thnn_nll_loss_forward not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor & _thnn_nll_loss_backward_out(Tensor & grad_input, const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_input.has_names() || grad_output.has_names() || self.has_names() || target.has_names() || weight.has_names() || total_weight.has_names()) {
        AT_ERROR("_thnn_nll_loss_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_nll_loss_backward_out", true, Backend::DPCPP, ScalarType::Double);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 7, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 7, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Double);
            THNN_SyclDoubleClassNLLCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            grad_input_->maybe_zero_dim(self_->dim() == 0);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_nll_loss_backward_out", true, Backend::DPCPP, ScalarType::Float);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 7, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 7, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Float);
            THNN_SyclClassNLLCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            grad_input_->maybe_zero_dim(self_->dim() == 0);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_nll_loss_backward_out", true, Backend::DPCPP, ScalarType::Half);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 7, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = checked_tensor_unwrap(grad_input, "grad_input", 7, "_thnn_nll_loss_backward_out", false, Backend::DPCPP, ScalarType::Half);
            THNN_SyclHalfClassNLLCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            grad_input_->maybe_zero_dim(self_->dim() == 0);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_nll_loss_backward_out not supported on SYCLType for ", dispatch_scalar_type);
    }
}
Tensor _thnn_nll_loss_backward(const Tensor & grad_output, const Tensor & self, const Tensor & target, const Tensor & weight, int64_t reduction, int64_t ignore_index, const Tensor & total_weight) {
#ifdef BUILD_NAMEDTENSOR
    if (grad_output.has_names() || self.has_names() || target.has_names() || weight.has_names() || total_weight.has_names()) {
        AT_ERROR("_thnn_nll_loss_backward: no named inference rule implemented.");
    }
#endif
    const OptionalDeviceGuard device_guard(device_of(self));
    auto dispatch_scalar_type = infer_scalar_type(self);
    switch (dispatch_scalar_type) {
        case ScalarType::Double: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_nll_loss_backward", true, Backend::DPCPP, ScalarType::Double);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 7, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Double);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<double>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclDoubleClassNLLCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            grad_input_->maybe_zero_dim(self_->dim() == 0);
            return grad_input;
            break;
        }
        case ScalarType::Float: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_nll_loss_backward", true, Backend::DPCPP, ScalarType::Float);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 7, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Float);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<float>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclClassNLLCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            grad_input_->maybe_zero_dim(self_->dim() == 0);
            return grad_input;
            break;
        }
        case ScalarType::Half: {
            auto grad_output_ = checked_tensor_unwrap(grad_output, "grad_output", 1, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto self_ = checked_tensor_unwrap(self, "self", 2, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto target_ = checked_tensor_unwrap(target, "target", 3, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Long);
            auto weight_ = checked_tensor_unwrap(weight, "weight", 4, "_thnn_nll_loss_backward", true, Backend::DPCPP, ScalarType::Half);
            auto total_weight_ = checked_tensor_unwrap(total_weight, "total_weight", 7, "_thnn_nll_loss_backward", false, Backend::DPCPP, ScalarType::Half);
            auto grad_input_ = c10::make_intrusive<TensorImpl, UndefinedTensorImpl>(c10::Storage(caffe2::TypeMeta::Make<Half>(), 0, allocator(), true),at::torch_ipex::DPCPPTensorId()).release();
            auto grad_input = Tensor(c10::intrusive_ptr<TensorImpl, UndefinedTensorImpl>::reclaim(grad_input_));
            THNN_SyclHalfClassNLLCriterion_updateGradInput(getTHSYCLState(), self_, target_, grad_output_, grad_input_, reduction, weight_ ? weight_ : NULL, total_weight_, ignore_index);
            grad_input_->maybe_zero_dim(self_->dim() == 0);
            return grad_input;
            break;
        }
        default:
            AT_ERROR("_thnn_nll_loss_backward not supported on SYCLType for ", dispatch_scalar_type);
    }
}

} // namespace th
} // namespace legacy
} // namespace native
} // namespace at
